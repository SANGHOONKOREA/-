<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesseract OCR 기반 다국어 명함 관리 앱</title>
    <!-- Tesseract.js for OCR - 최신 안정화 버전 사용 -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <!-- OpenCV.js for image preprocessing -->
    <script src="https://docs.opencv.org/4.7.0/opencv.js" type="text/javascript"></script>
    <!-- TensorFlow.js for AI-based text analysis -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans', 'Noto Sans KR', 'Noto Sans JP', 'Noto Sans SC', sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 100%;
            padding: 15px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 5px;
        }
        
        header p {
            color: #007bff;
            font-size: 0.9rem;
        }
        
        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .tab.active {
            background-color: #007bff;
            color: white;
        }
        
        .content {
            display: none;
        }
        
        .content.active {
            display: block;
        }
        
        .card-form {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .form-group textarea {
            height: 100px;
            resize: vertical;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: inline-block;
            margin-right: 10px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        .camera-container {
            width: 100%;
            position: relative;
            margin-bottom: 20px;
        }
        
        #video, #canvas, #capturedImage {
            width: 100%;
            border-radius: 8px;
            display: block;
        }
        
        #capturedImage {
            margin-top: 10px;
            display: none;
        }
        
        .progress-bar {
            height: 5px;
            background-color: #f0f0f0;
            margin-bottom: 15px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar-fill {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .progress-bar-pulse {
            height: 100%;
            width: 100%;
            position: absolute;
            background: linear-gradient(90deg, 
                transparent 0%, 
                transparent 40%, 
                rgba(255, 255, 255, 0.5) 50%, 
                transparent 60%, 
                transparent 100%);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .card-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }
        
        .card-item {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 15px;
            position: relative;
        }
        
        .card-item h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .card-details {
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .card-details p {
            margin-bottom: 5px;
        }
        
        .card-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
        }
        
        .card-actions button {
            padding: 8px 12px;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .delete-btn {
            background-color: #dc3545;
        }
        
        .delete-btn:hover {
            background-color: #c82333;
        }
        
        .edit-btn {
            background-color: #6c757d;
        }
        
        .edit-btn:hover {
            background-color: #5a6268;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 0;
            color: #6c757d;
        }
        
        #processingMessage {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            color: #007bff;
        }
        
        .search-container {
            margin-bottom: 20px;
        }
        
        #searchInput {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .hidden {
            display: none;
        }
        
        /* 언어 선택 */
        .language-selector {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .language-btn {
            margin: 0 5px;
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .language-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
            color: #aaa;
        }
        
        .close-modal:hover {
            color: #333;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
        }

        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* 추가된 스타일: 이미지 전처리 옵션 메뉴 */
        .preprocessing-options {
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        
        .preprocessing-options h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .option-item {
            display: flex;
            align-items: center;
        }
        
        .option-item input {
            margin-right: 5px;
        }
        
        /* 미리보기 컨테이너 스타일 */
        .preview-container {
            display: flex;
            margin-top: 10px;
            overflow-x: auto;
            gap: 10px;
            padding-bottom: 10px;
        }
        
        .preview-item {
            flex: 0 0 auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            width: 120px;
        }
        
        .preview-item img {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .preview-item p {
            font-size: 12px;
            text-align: center;
            padding: 4px;
            background-color: #f5f5f5;
        }
        
        /* 처리 단계 표시 */
        .steps-indicator {
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .step {
            flex: 1;
            min-width: 80px;
            text-align: center;
            padding: 8px 4px;
            background-color: #f0f0f0;
            border-right: 1px solid #ddd;
            font-size: 12px;
            position: relative;
        }
        
        .step:last-child {
            border-right: none;
        }
        
        .step.active {
            background-color: #e6f7ff;
            font-weight: bold;
        }
        
        .step.completed {
            background-color: #d4edda;
        }
        
        .step.current {
            background-color: #007bff;
            color: white;
        }
        
        /* 결과 신뢰도 표시 */
        .confidence-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .confidence-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin-right: 10px;
        }
        
        .confidence-fill {
            height: 100%;
            background-color: #28a745;
            width: 0%;
        }
        
        .confidence-text {
            font-size: 14px;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        /* 이미지 회전 버튼 */
        .rotate-buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        
        .rotate-buttons button {
            padding: 6px 12px;
            margin: 0 5px;
            font-size: 14px;
        }
        
        /* 원시 OCR 결과 */
        .raw-ocr-container {
            max-height: 200px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 15px;
            white-space: pre-wrap;
            word-break: break-all;
            display: none;
        }
        
        /* 명함 이미지 업로드 */
        .upload-container {
            margin-bottom: 15px;
            text-align: center;
        }
        
        #fileInput {
            display: none;
        }
        
        .upload-btn {
            padding: 8px 16px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .upload-btn:hover {
            background-color: #5a6268;
        }
        
        /* OpenCV 로딩 상태 */
        #opencvStatus {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            margin: 5px 0;
        }
        
        /* Tesseract 다운로드 상태 */
        #tesseractStatus {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            margin: 5px 0;
        }
        
        /* AI 모델 상태 */
        #aiModelStatus {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            margin: 5px 0;
        }
        
        /* 고급 모드 스위치 */
        .advanced-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin: 0 10px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        /* 로딩 스피너 */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* AI 분석 결과 */
        .ai-results {
            background-color: #f0f7ff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #b8daff;
            display: none;
        }
        
        .ai-results h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #0056b3;
        }
        
        .ai-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .ai-category {
            font-weight: bold;
            flex: 1;
        }
        
        .ai-text {
            flex: 2;
        }
        
        .ai-confidence {
            flex: 0 0 60px;
            text-align: right;
            color: #6c757d;
            font-size: 12px;
        }
        
        /* 명함 인식 가이드 스타일 */
        .card-detection-guide {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .guide-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 85%;
            height: 55%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(40, 167, 69, 0.8);
            border-radius: 8px;
            box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.3);
        }
        
        .guide-corner {
            position: absolute;
            width: 20px;
            height: 20px;
        }
        
        .corner-tl {
            top: -5px;
            left: -5px;
            border-top: 3px solid rgba(40, 167, 69, 1);
            border-left: 3px solid rgba(40, 167, 69, 1);
            border-top-left-radius: 4px;
        }
        
        .corner-tr {
            top: -5px;
            right: -5px;
            border-top: 3px solid rgba(40, 167, 69, 1);
            border-right: 3px solid rgba(40, 167, 69, 1);
            border-top-right-radius: 4px;
        }
        
        .corner-bl {
            bottom: -5px;
            left: -5px;
            border-bottom: 3px solid rgba(40, 167, 69, 1);
            border-left: 3px solid rgba(40, 167, 69, 1);
            border-bottom-left-radius: 4px;
        }
        
        .corner-br {
            bottom: -5px;
            right: -5px;
            border-bottom: 3px solid rgba(40, 167, 69, 1);
            border-right: 3px solid rgba(40, 167, 69, 1);
            border-bottom-right-radius: 4px;
        }
        
        .guide-text {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            transition: background-color 0.3s;
        }
        
        .auto-capture-btn {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            display: none;
            pointer-events: auto;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 101;
        }
        
        /* 카메라 컨트롤 영역 스타일 업데이트 */
        .camera-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 50;
        }
        
        /* 실시간 품질 분석 지표 스타일 */
        .quality-indicators {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 5px 10px;
            color: white;
            font-size: 12px;
            display: none;
        }
        
        .indicator-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        
        .indicator-label {
            flex: 1;
        }
        
        .indicator-bar {
            flex: 2;
            height: 6px;
            background-color: #444;
            border-radius: 3px;
            margin: 5px 10px 0 10px;
        }
        
        .indicator-fill {
            height: 100%;
            background-color: #007bff;
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .indicator-value {
            width: 30px;
            text-align: right;
        }
        
        /* 플래시 효과 스타일 */
        .flash-effect {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            opacity: 0;
            z-index: 999;
            transition: opacity 0.2s ease;
        }
        
        /* 비네팅 효과 (명함 강조) */
        .vignette-effect {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            background: radial-gradient(
                ellipse at center,
                transparent 40%,
                rgba(0, 0, 0, 0.3) 100%
            );
        }
        
        /* 조명 상태 아이콘 */
        .lighting-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
        }
        
        /* 품질 상세 정보 팝업 */
        .quality-details {
            position: absolute;
            bottom: 70px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 10px;
            color: white;
            font-size: 13px;
            z-index: 100;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .quality-details.active {
            max-height: 300px;
        }
        
        .details-toggle {
            position: absolute;
            right: 10px;
            bottom: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 101;
            cursor: pointer;
        }
        
        /* 카메라 안내 텍스트 강화 */
        .camera-guide {
            text-align: center;
            background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.7));
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .camera-guide h3 {
            margin-top: 0;
            color: #007bff;
        }
        
        .camera-guide ul {
            text-align: left;
            margin-bottom: 0;
            padding-left: 20px;
        }
        
        .camera-guide ul li {
            margin-bottom: 5px;
        }
        
        /* 툴팁 스타일 */
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .tooltip:after {
            content: '';
            position: absolute;
            border-style: solid;
            border-width: 5px;
        }
        
        .tooltip.top:after {
            border-color: #333 transparent transparent transparent;
            top: 100%;
            left: 50%;
            margin-left: -5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Tesseract OCR 기반 다국어 명함 관리 앱</h1>
            <p>고급 이미지 처리 및 AI 분석 기술 활용</p>
        </header>
        
        <div id="opencvStatus">OpenCV.js 로딩 중...</div>
        <div id="tesseractStatus">Tesseract 엔진 초기화 중...</div>
        <div id="aiModelStatus">AI 모델 준비 중...</div>
        
        <div class="tab-container">
            <div class="tab active" data-tab="camera">명함 추가</div>
            <div class="tab" data-tab="dashboard">대시보드</div>
            <div class="tab" data-tab="settings">설정</div>
        </div>
        
        <div id="cameraContent" class="content active">
            <div class="language-selector">
                <button class="language-btn active" data-lang="kor">한국어</button>
                <button class="language-btn" data-lang="eng">영어</button>
                <button class="language-btn" data-lang="jpn">일본어</button>
                <button class="language-btn" data-lang="chi_sim">중국어</button>
                <button class="language-btn" data-lang="multi">다국어</button>
            </div>
            
            <div class="advanced-switch">
                <span>일반 모드</span>
                <label class="switch">
                    <input type="checkbox" id="advancedModeToggle">
                    <span class="slider"></span>
                </label>
                <span>고급 모드</span>
            </div>
            
            <div class="camera-container">
                <button id="accessCameraBtn" class="primary-button">카메라 접근 허용</button>
                <video id="video" autoplay playsinline style="display: none;"></video>
                <canvas id="canvas" style="display: none;"></canvas>
                <img id="capturedImage" alt="촬영된 이미지">
                
                <div class="upload-container">
                    <input type="file" id="fileInput" accept="image/*">
                    <button id="uploadBtn" class="upload-btn">또는 이미지 업로드</button>
                </div>
                
                <!-- 이미지 회전 버튼 추가 -->
                <div class="rotate-buttons" style="display: none;" id="rotateButtons">
                    <button id="rotateLeftBtn">← 90° 회전</button>
                    <button id="rotateRightBtn">90° 회전 →</button>
                </div>
                
                <!-- 명함 인식 가이드 구성요소 -->
                <div id="cardScanningGuide" class="card-detection-guide" style="display: none;">
                    <div class="guide-frame">
                        <div class="guide-corner corner-tl"></div>
                        <div class="guide-corner corner-tr"></div>
                        <div class="guide-corner corner-bl"></div>
                        <div class="guide-corner corner-br"></div>
                    </div>
                    <div id="cardDetectionGuide" class="guide-text">명함을 가이드 영역 안에 맞춰주세요</div>
                    <button id="autoCaptureBtn" class="auto-capture-btn">최적 상태 감지됨 - 촬영하기</button>
                    
                    <div class="quality-indicators" id="qualityIndicators">
                        <div class="indicator-item">
                            <div class="indicator-label">밝기</div>
                            <div class="indicator-bar"><div class="indicator-fill" id="brightnessIndicator"></div></div>
                            <div class="indicator-value" id="brightnessValue">0%</div>
                        </div>
                        <div class="indicator-item">
                            <div class="indicator-label">선명도</div>
                            <div class="indicator-bar"><div class="indicator-fill" id="sharpnessIndicator"></div></div>
                            <div class="indicator-value" id="sharpnessValue">0%</div>
                        </div>
                        <div class="indicator-item">
                            <div class="indicator-label">정렬</div>
                            <div class="indicator-bar"><div class="indicator-fill" id="alignmentIndicator"></div></div>
                            <div class="indicator-value" id="alignmentValue">0%</div>
                        </div>
                    </div>
                    
                    <div id="qualityDetails" class="quality-details">
                        <h4 style="margin-top: 0;">품질 세부 정보</h4>
                        <div id="qualityDetailsList"></div>
                    </div>
                    
                    <button id="detailsToggle" class="details-toggle">i</button>
                    <div id="lightingIndicator" class="lighting-indicator">💡</div>
                    <div id="flashEffect" class="flash-effect"></div>
                    <div class="vignette-effect"></div>
                </div>
            </div>
            
            <div class="button-group" style="text-align: center; margin-bottom: 20px;">
                <button id="captureBtn" style="display: none;">명함 촬영</button>
                <button id="retakeBtn" style="display: none;">다시 촬영</button>
                <button id="analyzeBtn" style="display: none;">명함 분석</button>
                <button id="advancedBtn" style="display: none; background-color: #6c757d;">고급 옵션</button>
                <button id="improveImageBtn" style="display: none; background-color: #28a745;">이미지 개선</button>
            </div>
            
            <!-- AI 분석 결과 -->
            <div class="ai-results" id="aiResults">
                <h3>AI 분석 결과</h3>
                <div id="aiResultsList"></div>
            </div>
            
            <!-- 고급 전처리 옵션 -->
            <div class="preprocessing-options" id="preprocessingOptions">
                <h3>이미지 처리 옵션</h3>
                <div class="options-grid">
                    <div class="option-item">
                        <input type="checkbox" id="optGrayscale" checked>
                        <label for="optGrayscale">그레이스케일</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optAdaptiveThreshold">
                        <label for="optAdaptiveThreshold">적응형 이진화</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optContrast" checked>
                        <label for="optContrast">대비 향상</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optSharpen" checked>
                        <label for="optSharpen">선명하게</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optDenoise">
                        <label for="optDenoise">노이즈 제거</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optThreshold">
                        <label for="optThreshold">일반 이진화</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optEdgeEnhance">
                        <label for="optEdgeEnhance">윤곽선 강화</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="optDeskew">
                        <label for="optDeskew">기울기 보정</label>
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <button id="applyPreprocessingBtn">적용하기</button>
                    <button id="resetPreprocessingBtn" style="background-color: #6c757d;">원본으로 되돌리기</button>
                </div>
            </div>
            
            <!-- 처리 단계 표시 -->
            <div class="steps-indicator" id="stepsIndicator" style="display: none;">
                <div class="step" data-step="capture">이미지 촬영</div>
                <div class="step" data-step="preprocess">이미지 처리</div>
                <div class="step" data-step="ocr">텍스트 인식</div>
                <div class="step" data-step="extract">정보 추출</div>
                <div class="step" data-step="review">결과 확인</div>
            </div>
            
            <div id="statusMessage" class="status-message info" style="display: none;">명함 분석 준비 중...</div>
            
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-bar-fill" id="progressBarFill"></div>
                <div class="progress-bar-pulse" id="progressBarPulse" style="display: none;"></div>
            </div>
            
            <!-- 신뢰도 표시 -->
            <div class="confidence-indicator" id="confidenceIndicator" style="display: none;">
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                </div>
                <div class="confidence-text" id="confidenceText">0%</div>
            </div>
            
            <!-- 원시 OCR 결과 표시 -->
            <div class="raw-ocr-container" id="rawOcrResult" style="display: none;"></div>
            
            <!-- 미리보기 컨테이너 -->
            <div class="preview-container" id="previewContainer" style="display: none;">
                <!-- 여기에 미리보기 이미지가 추가됩니다 -->
            </div>
            
            <div class="card-form" id="cardForm" style="display: none;">
                <div class="form-group">
                    <label for="name">이름</label>
                    <input type="text" id="name" placeholder="이름을 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="position">직책</label>
                    <input type="text" id="position" placeholder="직책을 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="company">회사</label>
                    <input type="text" id="company" placeholder="회사명을 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="department">부서</label>
                    <input type="text" id="department" placeholder="부서를 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="phone">휴대폰 번호</label>
                    <input type="tel" id="phone" placeholder="휴대폰 번호를 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="email">이메일</label>
                    <input type="email" id="email" placeholder="이메일을 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="address">주소</label>
                    <input type="text" id="address" placeholder="주소를 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="website">웹사이트</label>
                    <input type="url" id="website" placeholder="웹사이트를 입력하세요">
                </div>
                
                <div class="form-group">
                    <label for="notes">메모</label>
                    <textarea id="notes" placeholder="이 사람에 대한 메모를 입력하세요"></textarea>
                </div>
                
                <button id="saveBtn">명함 저장</button>
            </div>
        </div>
        
        <div id="dashboardContent" class="content">
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="이름, 회사, 직책 등으로 검색">
            </div>
            
            <div id="cardList" class="card-list">
                <!-- 명함 목록이 여기에 동적으로 표시됩니다 -->
            </div>
            
            <div id="emptyState" class="empty-state">
                <p>등록된 명함이 없습니다.</p>
                <p>카메라 탭에서 새 명함을 추가해보세요.</p>
            </div>
        </div>
        
        <div id="settingsContent" class="content">
            <div class="card-form">
                <h2>OCR 설정</h2>
                
                <div class="form-group">
                    <label for="tesseractParams">Tesseract 고급 매개변수</label>
                    <textarea id="tesseractParams" placeholder="형식: 매개변수_이름=값 (한 줄에 하나씩)">tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,-@+():;/'\" 
preserve_interword_spaces=1
tessedit_pageseg_mode=4
textord_tabfind_force_vertical_text=0
textord_tablefind_recognize_tables=0</textarea>
                </div>
                
                <div class="form-group">
                    <label for="imageQuality">이미지 품질 (업로드 및 캡처)</label>
                    <select id="imageQuality">
                        <option value="0.6">낮음 (빠른 처리)</option>
                        <option value="0.8" selected>중간 (권장)</option>
                        <option value="0.95">높음 (느린 처리)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="showRawOcr">
                        OCR 원본 결과 표시
                    </label>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="autoPreprocess" checked>
                        자동 이미지 개선 적용
                    </label>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="useAI" checked>
                        AI 분석 사용 (더 정확한 명함 정보 인식)
                    </label>
                </div>
                
                <div class="form-group">
                    <label for="psm">PSM (Page Segmentation Mode)</label>
                    <select id="psm">
                        <option value="3">3 - 자동 페이지 분할 (기본값)</option>
                        <option value="4" selected>4 - 가변 크기 텍스트 단일 칼럼 가정</option>
                        <option value="6">6 - 단일 텍스트 블록 가정</option>
                        <option value="11">11 - 텍스트 회전 없이 희소 텍스트</option>
                        <option value="12">12 - 밀집된 텍스트 + OSD</option>
                    </select>
                </div>
                
                <button id="saveSettingsBtn">설정 저장</button>
                <button id="resetSettingsBtn" style="background-color: #6c757d;">기본값으로 재설정</button>
            </div>
            
            <div class="card-form" style="margin-top: 20px;">
                <h2>데이터 관리</h2>
                
                <div class="form-group">
                    <label>내보내기/가져오기</label>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="exportDataBtn">명함 데이터 내보내기</button>
                        <button id="importDataBtn">명함 데이터 가져오기</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>데이터 초기화</label>
                    <button id="clearDataBtn" style="background-color: #dc3545; margin-top: 10px;">모든 명함 데이터 삭제</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 명함 수정 모달 -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>명함 수정</h2>
            
            <div class="form-group">
                <label for="editName">이름</label>
                <input type="text" id="editName" placeholder="이름을 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editPosition">직책</label>
                <input type="text" id="editPosition" placeholder="직책을 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editCompany">회사</label>
                <input type="text" id="editCompany" placeholder="회사명을 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editDepartment">부서</label>
                <input type="text" id="editDepartment" placeholder="부서를 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editPhone">휴대폰 번호</label>
                <input type="tel" id="editPhone" placeholder="휴대폰 번호를 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editEmail">이메일</label>
                <input type="email" id="editEmail" placeholder="이메일을 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editAddress">주소</label>
                <input type="text" id="editAddress" placeholder="주소를 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editWebsite">웹사이트</label>
                <input type="url" id="editWebsite" placeholder="웹사이트를 입력하세요">
            </div>
            
            <div class="form-group">
                <label for="editNotes">메모</label>
                <textarea id="editNotes" placeholder="이 사람에 대한 메모를 입력하세요"></textarea>
            </div>
            
            <button id="updateBtn">수정 완료</button>
        </div>
    </div>
    
    <!-- 데이터 가져오기 모달 -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <span class="close-modal import-close">&times;</span>
            <h2>명함 데이터 가져오기</h2>
            
            <div class="form-group">
                <label for="importData">JSON 데이터</label>
                <textarea id="importData" placeholder="내보낸 JSON 데이터를 여기에 붙여넣으세요" rows="10"></textarea>
            </div>
            
            <button id="confirmImportBtn">가져오기</button>
            <button class="import-close" style="background-color: #6c757d;">취소</button>
        </div>
    </div>
    

<script>
    // 호환성 도우미 함수들 - 스크립트 최상단에 추가
    function boxPoints(rotatedRect) {
        try {
            // 최신 OpenCV.js 버전에서 boxPoints 함수 사용 시도
            return cv.boxPoints(rotatedRect);
        } catch (e) {
            console.log('boxPoints 함수 대체 사용');
            // 수동으로 회전된 사각형의 점들 계산
            const center = rotatedRect.center;
            const size = rotatedRect.size;
            const angle = rotatedRect.angle * Math.PI / 180.0; // 라디안 변환
            
            const b = Math.cos(angle) * 0.5;
            const a = Math.sin(angle) * 0.5;
            
            // Float32Array 생성 (OpenCV 방식과 유사하게)
            const points_data = new Float32Array(8);
            
            // 네 꼭지점 계산 및 배열에 저장
            points_data[0] = center.x - a * size.height - b * size.width; 
            points_data[1] = center.y + b * size.height - a * size.width;
            
            points_data[2] = center.x + a * size.height - b * size.width; 
            points_data[3] = center.y - b * size.height - a * size.width;
            
            points_data[4] = center.x + a * size.height + b * size.width; 
            points_data[5] = center.y - b * size.height + a * size.width;
            
            points_data[6] = center.x - a * size.height + b * size.width; 
            points_data[7] = center.y + b * size.height + a * size.width;
            
            return {
                data32F: points_data
            };
        }
    }

    // 노이즈 제거 안전 함수
    function safeNlMeansDenoising(src, dst, h = 10, templateWindowSize = 7, searchWindowSize = 21) {
        try {
            // 최신 버전 사용 시도
            cv.fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize);
        } catch (e) {
            console.log('fastNlMeansDenoising 함수 대체 사용');
            // 대체 기능: 가우시안 블러 적용
            cv.GaussianBlur(src, dst, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
        }
    }

    // DOM 요소
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const capturedImage = document.getElementById('capturedImage');
        const captureBtn = document.getElementById('captureBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const cardForm = document.getElementById('cardForm');
        const saveBtn = document.getElementById('saveBtn');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const progressBarFill = document.getElementById('progressBarFill');
        const progressBarPulse = document.getElementById('progressBarPulse');
        const cardList = document.getElementById('cardList');
        const emptyState = document.getElementById('emptyState');
        const searchInput = document.getElementById('searchInput');
        const editModal = document.getElementById('editModal');
        const closeModal = document.querySelector('.close-modal');
        const updateBtn = document.getElementById('updateBtn');
        const accessCameraBtn = document.getElementById('accessCameraBtn');
        const languageButtons = document.querySelectorAll('.language-btn');
        const improveImageBtn = document.getElementById('improveImageBtn');
        const advancedBtn = document.getElementById('advancedBtn');
        const preprocessingOptions = document.getElementById('preprocessingOptions');
        const applyPreprocessingBtn = document.getElementById('applyPreprocessingBtn');
        const resetPreprocessingBtn = document.getElementById('resetPreprocessingBtn');
        const confidenceIndicator = document.getElementById('confidenceIndicator');
        const confidenceFill = document.getElementById('confidenceFill');
        const confidenceText = document.getElementById('confidenceText');
        const stepsIndicator = document.getElementById('stepsIndicator');
        const previewContainer = document.getElementById('previewContainer');
        const rotateButtons = document.getElementById('rotateButtons');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const rawOcrResult = document.getElementById('rawOcrResult');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const tesseractParams = document.getElementById('tesseractParams');
        const imageQuality = document.getElementById('imageQuality');
        const showRawOcr = document.getElementById('showRawOcr');
        const autoPreprocess = document.getElementById('autoPreprocess');
        const useAI = document.getElementById('useAI');
        const psm = document.getElementById('psm');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const resetSettingsBtn = document.getElementById('resetSettingsBtn');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const clearDataBtn = document.getElementById('clearDataBtn');
        const importModal = document.getElementById('importModal');
        const importData = document.getElementById('importData');
        const confirmImportBtn = document.getElementById('confirmImportBtn');
        const importClose = document.querySelectorAll('.import-close');
        const opencvStatus = document.getElementById('opencvStatus');
        const tesseractStatus = document.getElementById('tesseractStatus');
        const aiModelStatus = document.getElementById('aiModelStatus');
        const advancedModeToggle = document.getElementById('advancedModeToggle');
        const aiResults = document.getElementById('aiResults');
        const aiResultsList = document.getElementById('aiResultsList');
        
// 처리 단계 업데이트 함수
function updateProcessingStep(step) {
    processingStep = step;
    
    // 모든 단계 스타일 초기화
    const stepElements = document.querySelectorAll('.step');
    if (stepElements.length === 0) return; // 요소가 없으면 중단
    
    stepElements.forEach(el => {
        el.classList.remove('active', 'completed', 'current');
    });
    
    // 현재 단계까지 활성화
    const steps = ['capture', 'preprocess', 'ocr', 'extract', 'review'];
    const currentIndex = steps.indexOf(step);
    
    if (currentIndex >= 0) {
        for (let i = 0; i < steps.length; i++) {
            const el = document.querySelector(`.step[data-step="${steps[i]}"]`);
            if (el) { // 요소가 존재하는지 확인
                if (i < currentIndex) {
                    el.classList.add('completed');
                } else if (i === currentIndex) {
                    el.classList.add('current');
                }
            }
        }
    }
}


        // 변수 추가
        let isCardDetectionActive = false;
        let cardDetectionTimer = null;
        let lastDetectionResult = null;
        let realTimeBoundaryDetection = true;
        
        // 언어 선택
        let selectedLanguage = 'kor';
        
        // 설정 객체
        let appSettings = {
            tesseractParams: "tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,-@+():;/'\" \npreserve_interword_spaces=1\ntessedit_pageseg_mode=4\ntextord_tabfind_force_vertical_text=0\ntextord_tablefind_recognize_tables=0",
            imageQuality: "0.8",
            showRawOcr: false,
            autoPreprocess: true,
            useAI: true,
            psm: "4"
        };
        
        // 전역 변수
        let tesseractWorker = null;
        let useModel = null;
        let isOpencvReady = false;
        let isTesseractReady = false;
        let isAiModelReady = false;
        let isModelLoading = false;
        let isAdvancedMode = false;
        
        // 탭 관련 변수
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.content');
        
        // 현재 편집 중인 명함 ID
        let currentEditId = null;
        
        // 원본 이미지 데이터 저장
        let originalImageData = null;
        
        // 현재 이미지 회전 각도
        let currentRotation = 0;
        
        // 처리 단계 진행 상태
        let processingStep = 'capture';
        
        // OCR 결과 저장용 변수
        let lastOcrResult = null;
        
        // 명함 데이터 변수
        let businessCards = [];
        
        // OpenCV 모듈 로드 체크
        function onOpenCvReady() {
            isOpencvReady = true;
            opencvStatus.textContent = "OpenCV.js 로드 완료";
            opencvStatus.style.color = "#155724";
            checkAllModulesReady();
        }
        
        // OpenCV 모듈 초기화
        window.onOpenCvReady = onOpenCvReady;
        
        // 모델 로딩 함수
        async function loadUSEModel() {
            if (useModel) return useModel;
            if (isModelLoading) return null;
            
            isModelLoading = true;
            try {
                aiModelStatus.innerHTML = '<div class="spinner"></div> AI 분석 모델 로딩 중...';
                
                // TensorFlow.js와 모델을 직접 동적으로 로드
                try {
                    // 모델을 동적으로 가져오기
                    useModel = await tf.loadGraphModel('https://tfhub.dev/tensorflow/tfjs-model/universal-sentence-encoder-lite/1/default/1', { fromTFHub: true });
                    
                    isAiModelReady = true;
                    aiModelStatus.textContent = "AI 모델 준비 완료";
                    aiModelStatus.style.color = "#155724";
                    
                    checkAllModulesReady();
                    return useModel;
                } catch (loadError) {
                    console.error('모델 로드 오류:', loadError);
                    throw loadError;
                }
            } catch (error) {
                console.error('AI 모델 로딩 오류:', error);
                aiModelStatus.textContent = "AI 모델 로드 실패 - 일반 분석을 사용합니다";
                aiModelStatus.style.color = "#721c24";
                
                // AI 기능 비활성화
                appSettings.useAI = false;
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
                
                return null;
            } finally {
                isModelLoading = false;
            }
        }
        
        // 텍스트 유사도 비교 함수
        async function findMostSimilarCategory(text, categories) {
            try {
                const model = await loadUSEModel();
                if (!model) return null;
                
                // AI 모델 없이 간단한 규칙 기반 분석으로 대체
                // 각 카테고리 키워드에 대한 일치 점수 계산
                const scores = {};
                const lowerText = text.toLowerCase();
                
                Object.keys(categories).forEach(category => {
                    const examples = categories[category].toLowerCase().split(' ');
                    let score = 0;
                    
                    // 단어 일치 검색
                    examples.forEach(example => {
                        if (lowerText.includes(example)) {
                            score += example.length; // 긴 단어에 더 높은 점수
                        }
                    });
                    
                    // 특정 패턴 검사 (이메일, 전화번호 등)
                    if (category === "이메일" && /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g.test(text)) {
                        score += 100;
                    } else if (category === "전화번호" && /(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{3,4}/g.test(text)) {
                        score += 100;
                    } else if (category === "웹사이트" && /(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+/g.test(text)) {
                        score += 100;
                    }
                    
                    scores[category] = score;
                });
                
                // 최고 점수 카테고리 찾기
                let bestCategory = null;
                let highestScore = 0;
                
                Object.keys(scores).forEach(category => {
                    if (scores[category] > highestScore) {
                        highestScore = scores[category];
                        bestCategory = category;
                    }
                });
                
                // 유사도 점수 정규화 (0-1 범위로)
                const normalizedScore = highestScore > 0 ? Math.min(highestScore / 100, 1) : 0;
                
                return { 
                    category: bestCategory, 
                    similarity: normalizedScore 
                };
            } catch (error) {
                console.error('유사도 분석 오류:', error);
                return null;
            }
        }
        
        // 코사인 유사도 계산
        function cosineSimilarity(a, b) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            normA = Math.sqrt(normA);
            normB = Math.sqrt(normB);
            
            return dotProduct / (normA * normB);
        }
        
        // Tesseract 초기화
        async function initTesseract() {
            try {
                tesseractStatus.innerHTML = '<div class="spinner"></div> Tesseract 엔진 초기화 중...';
                
                // 기존 워커가 있으면 종료
                if (tesseractWorker) {
                    await tesseractWorker.terminate();
                }
                
                // 새 워커 생성
                tesseractWorker = await Tesseract.createWorker({
                    logger: progress => {
                        if (progress.status === 'downloading') {
                            tesseractStatus.innerHTML = `<div class="spinner"></div> 언어 데이터 다운로드 중: ${Math.round(progress.progress * 100)}%`;
                        } else if (progress.status === 'recognizing text') {
                            const percentage = Math.round(progress.progress * 100);
                            progressBarFill.style.width = `${percentage}%`;
                        }
                    }
                });
                
                // 한국어 로드
                await tesseractWorker.loadLanguage('kor');
                await tesseractWorker.initialize('kor');
                
                // PSM 설정
                const psmValue = parseInt(appSettings.psm || "4");
                await tesseractWorker.setParameters({
                    preserve_interword_spaces: '1',
                    tessedit_pageseg_mode: psmValue.toString()
                });
                
                // 설정에서 테서렉트 파라미터 로드
                if (appSettings.tesseractParams) {
                    const params = parseTesseractParams(appSettings.tesseractParams);
                    if (Object.keys(params).length > 0) {
                        await tesseractWorker.setParameters(params);
                    }
                }
                
                isTesseractReady = true;
                tesseractStatus.textContent = "Tesseract 엔진 준비 완료";
tesseractStatus.style.color = "#155724";
                checkAllModulesReady();
                
            } catch (error) {
                console.error('Tesseract 초기화 오류:', error);
                tesseractStatus.textContent = "Tesseract 초기화 실패 - 새로고침 후 다시 시도하세요";
                tesseractStatus.style.color = "#721c24";
            }
        }
        
        // 모든 모듈 준비 확인
        function checkAllModulesReady() {
            if (isOpencvReady && isTesseractReady) {
                // UI 활성화
                accessCameraBtn.disabled = false;
                uploadBtn.disabled = false;
                
                // 상태 메시지 업데이트
                showStatus('모든 기본 모듈이 로드되었습니다. 명함을 촬영하거나 업로드하세요.', 'success');
                
                // 상태 표시 숨기기 (3초 후)
                setTimeout(() => {
                    opencvStatus.style.display = 'none';
                    tesseractStatus.style.display = 'none';
                    
                    if (isAiModelReady) {
                        aiModelStatus.style.display = 'none';
                    }
                }, 3000);
            }
        }
        
        // Tesseract 파라미터 파싱
        function parseTesseractParams(paramsStr) {
            const params = {};
            const lines = paramsStr.split('\n');
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('#')) {
                    const [key, value] = trimmedLine.split('=');
                    if (key && value !== undefined) {
                        params[key.trim()] = value.trim();
                    }
                }
            }
            
            return params;
        }
        
        // 언어별 인식 설정
        const languageMap = {
            'kor': { 
                lang: 'kor',
                label: '한국어',
                keywords: {
                    company: ['주식회사', '(주)', '㈜', '기업', '그룹', '연구소', '학교', '대학교', '유한회사', '재단', '협회', '센터', '공사', '은행'],
                    position: ['대표', '사장', '이사', '부장', '차장', '과장', '대리', '사원', '연구원', '책임', '선임', '수석', '팀장', '매니저', '컨설턴트', '변호사', '교수', '원장', '소장', '실장', '전문가', '대표이사', '부사장', '전무', '상무', '센터장', '팀장', '교사', '강사'],
                    department: ['부', '팀', '과', '실', '본부', '센터', '연구소', '사업부', '영업', '마케팅', '개발', '기획', '인사', '총무', '재무', '회계', '관리', '생산', '품질', 'R&D', '비서', '법무', '홍보', '교육', '서비스', '고객', '지원'],
                    contactKeywords: ['전화', '휴대폰', '핸드폰', '모바일', '연락처', 'Tel', 'Mobile', '팩스', 'Fax', '이메일', 'Email', 'e-mail', '메일', '주소', 'Address', '홈페이지', '웹사이트', 'Website', 'Homepage', 'http', 'www'],
                    emailRegex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    phoneRegex: /(?:(?:\+|00)?82|0)?[ -]?(?:(?:(?:1[0-9]|[2-6][1-3]|70)[ -]?[0-9]{3,4})|(?:50[1-9])[ -]?[0-9]{2,3})[ -]?[0-9]{4}$/
                }
            },
            'eng': { 
                lang: 'eng',
                label: '영어',
                keywords: {
                    company: ['Inc.', 'LLC', 'Corp', 'Corporation', 'Company', 'Co.', 'Ltd', 'Limited', 'Group', 'Institute', 'University', 'College', 'Association', 'Foundation', 'Society', 'Partners', 'Consultants', 'Agency', 'Bank', 'Industries', 'International', 'Systems', 'Solutions', 'Services'],
                    position: ['CEO', 'CTO', 'CFO', 'COO', 'President', 'Director', 'Manager', 'Executive', 'Associate', 'Assistant', 'Specialist', 'Engineer', 'Consultant', 'Analyst', 'Officer', 'Supervisor', 'Coordinator', 'Representative', 'Developer', 'Designer', 'Chief', 'Lead', 'Senior', 'Junior', 'VP', 'Head', 'Partner', 'Founder', 'Chairman', 'Principal', 'Attorney', 'Lawyer', 'Doctor', 'Professor'],
                    department: ['Department', 'Division', 'Team', 'Group', 'Unit', 'R&D', 'HR', 'Sales', 'Marketing', 'Finance', 'IT', 'Development', 'Engineering', 'Support', 'Service', 'Operations', 'Accounting', 'Administration', 'Management', 'Legal', 'Communications', 'Research', 'Production', 'Quality', 'Procurement', 'Customer', 'Product', 'Business', 'Corporate'],
                    contactKeywords: ['Tel', 'Phone', 'Mobile', 'Cell', 'Contact', 'Fax', 'Email', 'E-mail', 'Mail', 'Address', 'Website', 'Homepage', 'Web', 'URL', 'http', 'www'],
                    emailRegex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    phoneRegex: /(?:\+?1[-\s\.]?)?\(?([0-9]{3})\)?[-\s\.]?([0-9]{3})[-\s\.]?([0-9]{4})/g
                }
            },
            'jpn': { 
                lang: 'jpn',
                label: '일본어',
                keywords: {
                    company: ['株式会社', '(株)', '有限会社', '団体', 'グループ', '研究所', '学校', '大学', '財団', '協会', 'センター', '公社', '銀行', '合同会社', '相互会社', '企業', '事務所'],
                    position: ['代表', '社長', '取締役', '部長', '課長', '係長', '主任', '社員', '研究員', 'マネージャー', 'コンサルタント', '教授', '講師', '秘書', '専門家', '弁護士', '医師', '技師', 'エンジニア', 'デザイナー', 'ディレクター', 'プロデューサー', 'コーディネーター'],
                    department: ['部', '課', 'チーム', '本部', 'センター', '研究所', '事業部', '営業', 'マーケティング', '開発', '企画', '人事', '総務', '財務', '経理', '管理', '生産', '品質', '調達', '購買', 'カスタマー', '顧客', 'サポート', 'サービス'],
                    contactKeywords: ['電話', 'Tel', '携帯', 'Mobile', 'ファックス', 'Fax', 'メール', 'Email', 'E-mail', '住所', 'Address', 'ウェブサイト', 'ホームページ', 'Website', 'Homepage', 'http', 'www'],
                    emailRegex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    phoneRegex: /(?:(?:\+?81)|0)[-\s]?(?:[1-9]0(?:[1-9]|0)|\d{2}|\d{1})[-\s]?\d{4}[-\s]?\d{4}/g
                }
            },
            'chi_sim': { 
                lang: 'chi_sim',
                label: '중국어',
                keywords: {
                    company: ['有限公司', '股份公司', '公司', '集团', '研究所', '学校', '大学', '基金会', '协会', '中心', '银行', '企业', '事务所', '工作室', '合伙人', '工厂', '制造'],
                    position: ['总裁', '董事长', '总经理', '经理', '主管', '主任', '职员', '研究员', '顾问', '专家', '工程师', '设计师', '总监', '副总', '执行官', '律师', '医生', '教授', '讲师', '助理', '主席', '秘书', '负责人'],
                    department: ['部', '组', '科', '处', '中心', '研究所', '事业部', '销售', '市场', '开发', '策划', '人事', '行政', '财务', '会计', '管理', '生产', '品质', '采购', '客户', '服务', '支持', '技术', '法务', '宣传', '教育'],
                    contactKeywords: ['电话', 'Tel', '手机', 'Mobile', '传真', 'Fax', '电子邮件', 'Email', 'E-mail', '邮箱', '地址', 'Address', '网站', 'Website', '主页', 'Homepage', 'http', 'www'],
                    emailRegex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    phoneRegex: /(?:\+?86)?[-\s]?(?:(?:1[3-9][0-9]))[-\s]?[0-9]{4}[-\s]?[0-9]{4}|(?:\d{3,4})[-\s]?(?:\d{7,8})/g
                }
            },
            'multi': { 
                lang: 'kor+eng+jpn+chi_sim',
                label: '다국어',
                keywords: {
                    company: [
                        // 한국어
                        '주식회사', '(주)', '㈜', '기업', '그룹', '연구소', '학교', '대학교', '유한회사', '재단', '협회', '센터', '공사', '은행',
                        // 영어
                        'Inc.', 'LLC', 'Corp', 'Corporation', 'Company', 'Co.', 'Ltd', 'Limited', 'Group', 'Institute', 'University', 'College', 'Association', 'Foundation', 'Society', 'Partners', 'Consultants', 'Agency', 'Bank',
                        // 일본어
                        '株式会社', '(株)', '有限会社', '団体', 'グループ', '研究所', '学校', '大学', '財団', '協会', 'センター', '公社', '銀行',
                        // 중국어
                        '有限公司', '股份公司', '公司', '集团', '研究所', '学校', '大学', '基金会', '协会', '中心', '银行'
                    ],
                    position: [
                        // 한국어
                        '대표', '사장', '이사', '부장', '차장', '과장', '대리', '사원', '연구원', '책임', '선임', '수석', '팀장', '매니저', '컨설턴트', '변호사', '교수', '원장', '소장',
                        // 영어
                        'CEO', 'CTO', 'CFO', 'COO', 'President', 'Director', 'Manager', 'Executive', 'Associate', 'Assistant', 'Specialist', 'Engineer', 'Consultant', 'Analyst', 'Officer', 'Supervisor', 'Coordinator', 'Representative', 'Developer', 'Designer',
                        // 일본어
                        '代表', '社長', '取締役', '部長', '課長', '係長', '主任', '社員', '研究員', 'マネージャー', 'コンサルタント', '教授', '講師',
                        // 중국어
                        '总裁', '董事长', '总经理', '经理', '主管', '主任', '职员', '研究员', '顾问', '专家', '工程师', '设计师', '总监'
                    ],
                    department: [
                        // 한국어
'부', '팀', '과', '실', '본부', '센터', '연구소', '사업부', '영업', '마케팅', '개발', '기획', '인사', '총무', '재무', '회계', '관리', '생산', '품질',
                        // 영어
                        'Department', 'Division', 'Team', 'Group', 'Unit', 'R&D', 'HR', 'Sales', 'Marketing', 'Finance', 'IT', 'Development', 'Engineering', 'Support', 'Service', 'Operations', 'Accounting', 'Administration', 'Management',
                        // 일본어
                        '部', '課', 'チーム', '本部', 'センター', '研究所', '事業部', '営業', 'マーケティング', '開発', '企画', '人事', '総務', '財務', '経理',
                        // 중국어
                        '部', '组', '科', '处', '中心', '研究所', '事业部', '销售', '市场', '开发', '策划', '人事', '行政', '财务', '会计'
                    ],
                    contactKeywords: [
                        // 한국어
                        '전화', '휴대폰', '핸드폰', '모바일', '팩스', '이메일', '메일', '주소', '홈페이지', '웹사이트',
                        // 영어
                        'Tel', 'Phone', 'Mobile', 'Cell', 'Fax', 'Email', 'E-mail', 'Mail', 'Address', 'Website', 'Homepage',
                        // 일본어
                        '電話', '携帯', 'ファックス', 'メール', '住所', 'ウェブサイト', 'ホームページ',
                        // 중국어
                        '电话', '手机', '传真', '电子邮件', '邮箱', '地址', '网站', '主页',
                        // 공통
                        'http', 'www'
                    ],
                    emailRegex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    // 통합 전화번호 패턴
                    phoneRegex: /(?:(?:\+|00)?82|0)?[ -]?(?:(?:(?:1[0-9]|[2-6][1-3]|70)[ -]?[0-9]{3,4})|(?:50[1-9])[ -]?[0-9]{2,3})[ -]?[0-9]{4}$|(?:\+?1[-\s\.]?)?\(?([0-9]{3})\)?[-\s\.]?([0-9]{3})[-\s\.]?([0-9]{4})|(?:(?:\+?81)|0)[-\s]?(?:[1-9]0(?:[1-9]|0)|\d{2}|\d{1})[-\s]?\d{4}[-\s]?\d{4}|(?:\+?86)?[-\s]?(?:(?:1[3-9][0-9]))[-\s]?[0-9]{4}[-\s]?[0-9]{4}|(?:\d{3,4})[-\s]?(?:\d{7,8})/g
                }
            }
        };
        
        // 설정 로드
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('appSettings');
                if (savedSettings) {
                    appSettings = JSON.parse(savedSettings);
                    
                    // 설정 폼에 값 설정
                    tesseractParams.value = appSettings.tesseractParams || '';
                    imageQuality.value = appSettings.imageQuality || '0.8';
                    showRawOcr.checked = appSettings.showRawOcr || false;
                    autoPreprocess.checked = appSettings.autoPreprocess !== false;
                    useAI.checked = appSettings.useAI !== false;
                    psm.value = appSettings.psm || '4';
                    
                    // 실시간 명함 감지 설정
                    realTimeBoundaryDetection = appSettings.realTimeBoundaryDetection !== false;
                    
                    // 명함 감지 토글 설정 추가
                    setTimeout(addCardDetectionToggle, 500);
                }
            } catch (error) {
                console.error('설정 로드 오류:', error);
                // 기본 설정 유지
            }
        }
        
        // 설정 저장
        function saveSettings() {
            try {
                appSettings.tesseractParams = tesseractParams.value;
                appSettings.imageQuality = imageQuality.value;
                appSettings.showRawOcr = showRawOcr.checked;
                appSettings.autoPreprocess = autoPreprocess.checked;
                appSettings.useAI = useAI.checked;
                appSettings.psm = psm.value;
                
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
                showStatus('설정이 저장되었습니다.', 'success');
                
                // Tesseract 워커 재초기화 (설정 변경 적용)
                initTesseract();
                
            } catch (error) {
                console.error('설정 저장 오류:', error);
                showStatus('설정 저장 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // 설정 초기화
        function resetSettings() {
            if (confirm('모든 설정을 기본값으로 초기화하시겠습니까?')) {
                appSettings = {
                    tesseractParams: "tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,-@+():;/'\" \npreserve_interword_spaces=1\ntessedit_pageseg_mode=4\ntextord_tabfind_force_vertical_text=0\ntextord_tablefind_recognize_tables=0",
                    imageQuality: "0.8",
                    showRawOcr: false,
                    autoPreprocess: true,
                    useAI: true,
                    psm: "4",
                    realTimeBoundaryDetection: true
                };
                
                // 설정 폼 초기화
                tesseractParams.value = appSettings.tesseractParams;
                imageQuality.value = appSettings.imageQuality;
                showRawOcr.checked = appSettings.showRawOcr;
                autoPreprocess.checked = appSettings.autoPreprocess;
                useAI.checked = appSettings.useAI;
                psm.value = appSettings.psm;
                
                // 실시간 감지 설정
                if (document.getElementById('cardDetectionToggle')) {
                    document.getElementById('cardDetectionToggle').checked = true;
                }
                realTimeBoundaryDetection = true;
                
                // 설정 저장 및 Tesseract 재초기화
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
                showStatus('설정이 초기화되었습니다.', 'success');
                
                // Tesseract 워커 재초기화
                initTesseract();
            }
        }
        
        // 언어 선택 이벤트
        languageButtons.forEach(btn => {
            btn.addEventListener('click', async () => {
                // 이전 활성화된 버튼 비활성화
                document.querySelector('.language-btn.active').classList.remove('active');
                
                // 현재 버튼 활성화
                btn.classList.add('active');
                
                // 선택된 언어 설정
                const newLanguage = btn.getAttribute('data-lang');
                
                // 언어가 변경된 경우에만 처리
                if (selectedLanguage !== newLanguage) {
                    selectedLanguage = newLanguage;
                    
                    // Tesseract 워커 언어 변경
                    await changeTesseractLanguage(selectedLanguage);
                }
            });
        });
        
        // Tesseract 언어 변경 함수
        async function changeTesseractLanguage(langCode) {
            try {
                showStatus(`${languageMap[langCode].label} 언어 모델 로드 중...`, 'info');
                
                // 언어 변경
                // Tesseract.js v4에서는 언어 변경 방법이 다름
                try {
                    await tesseractWorker.loadLanguage(languageMap[langCode].lang);
                    await tesseractWorker.initialize(languageMap[langCode].lang);
                    
                    // 파라미터 다시 설정
                    const psmValue = parseInt(appSettings.psm || "4");
                    await tesseractWorker.setParameters({
                        preserve_interword_spaces: '1',
                        tessedit_pageseg_mode: psmValue.toString()
                    });
                    
                    // 설정에서 테서렉트 파라미터 로드
                    if (appSettings.tesseractParams) {
                        const params = parseTesseractParams(appSettings.tesseractParams);
                        if (Object.keys(params).length > 0) {
                            await tesseractWorker.setParameters(params);
                        }
                    }
                } catch (error) {
                    console.error('언어 변경 중 오류:', error);
                    // 실패 시 워커 재생성 시도
                    await tesseractWorker.terminate();
                    tesseractWorker = await Tesseract.createWorker();
                    await tesseractWorker.loadLanguage(languageMap[langCode].lang);
                    await tesseractWorker.initialize(languageMap[langCode].lang);
                    
                    // 파라미터 다시 설정
                    const psmValue = parseInt(appSettings.psm || "4");
                    await tesseractWorker.setParameters({
                        preserve_interword_spaces: '1',
                        tessedit_pageseg_mode: psmValue.toString()
                    });
                }
                
                showStatus(`${languageMap[langCode].label} 언어 모델 로드 완료`, 'success');
            } catch (error) {
                console.error('언어 변경 오류:', error);
                showStatus('언어 모델 변경 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // 탭 전환 이벤트
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.getAttribute('data-tab');
                
                // 탭 활성화
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // 콘텐츠 활성화
                contents.forEach(content => {
                    content.classList.remove('active');
                });
                
                document.getElementById(targetTab + 'Content').classList.add('active');
                
                // 대시보드 탭 클릭 시 명함 목록 새로고침
                if (targetTab === 'dashboard') {
                    renderCardList();
                }
            });
        });
        
        // 고급 모드 토글
        advancedModeToggle.addEventListener('change', function() {
            isAdvancedMode = this.checked;
            
            // 고급 모드에 따라 UI 요소 표시/숨김
            if (isAdvancedMode) {
                if (rawOcrResult) rawOcrResult.style.display = 'block';
                advancedBtn.style.display = 'inline-block';
                if (aiResults) aiResults.style.display = 'block';
            } else {
                if (rawOcrResult) rawOcrResult.style.display = 'none';
                if (preprocessingOptions.style.display !== 'none') {
                    preprocessingOptions.style.display = 'none';
                    advancedBtn.textContent = '고급 옵션';
                }
                advancedBtn.style.display = 'none';
                if (aiResults) aiResults.style.display = 'none';
            }
        });
        
        // 카메라 접근 버튼 이벤트 핸들러 수정
        accessCameraBtn.addEventListener('click', async () => {
            try {
                // 카메라 스트림 가져오기 전에 이전 스트림 정리
                if (video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                }
                
                // 카메라 접근 요청 (고해상도 옵션 추가)
                const constraints = {
                    audio: false,
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1920 },  // 고해상도로 변경
                        height: { ideal: 1080 }, // 고해상도로 변경
                        frameRate: { ideal: 30 },
                        focusMode: { ideal: 'continuous' }, // 연속 자동 초점
                        exposureMode: { ideal: 'continuous' }, // 연속 자동 노출
                        whiteBalanceMode: { ideal: 'continuous' } // 연속 자동 화이트밸런스
                    }
                };
                
                console.log('고급 카메라 접근 요청 중...');
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('고급 카메라 접근 성공!', stream);
                    setupCameraStream(stream);
                } catch (advancedError) {
                    console.warn('고급 카메라 기능 접근 실패, 기본 모드로 시도합니다.', advancedError);
                    
                    // 기본 옵션으로 다시 시도
                    const basicConstraints = {
                        audio: false,
                        video: {
                            facingMode: { ideal: 'environment' }
                        }
                    };
                    
                    const basicStream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                    console.log('기본 카메라 접근 성공', basicStream);
                    setupCameraStream(basicStream);
                }
                
            } catch (error) {
                console.error('카메라 접근 오류:', error);
                showStatus(`카메라 접근 오류: ${error.name} - ${error.message}. 파일 업로드를 사용해보세요.`, 'error');
            }
        });
        
        // 카메라 스트림 설정 함수
        function setupCameraStream(stream) {
            // 비디오에 스트림 연결
            video.srcObject = stream;
            video.style.display = 'block';
            
            // 명함 스캔 가이드 표시
            document.getElementById('cardScanningGuide').style.display = 'block';
            
            // 버튼 표시 상태 업데이트
            captureBtn.style.display = 'inline-block';
            accessCameraBtn.style.display = 'none';
            
            // 품질 지표 표시
            document.getElementById('qualityIndicators').style.display = 'block';
            
            showStatus('카메라 접근 성공! 명함을 가이드 영역에 맞춰주세요.', 'success');
            
            // 실시간 명함 감지 시작 (비디오가 로드된 후)
            video.onloadedmetadata = () => {
                // 캔버스 크기 설정
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // 실시간 명함 감지 시작 (설정에 따라)
                if (realTimeBoundaryDetection) {
                    startRealTimeCardDetection();
                }
                

// 처리 단계 업데이트 함수


                // 처리 단계 업데이트
                updateProcessingStep('capture');
            };
        }
        
        // 파일 업로드 버튼 클릭 이벤트
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        // 파일 선택 이벤트
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    // 이미지 표시
                    capturedImage.src = event.target.result;
                    capturedImage.style.display = 'block';
                    
                    // 원본 이미지 저장
                    originalImageData = event.target.result;
                    
                    // UI 업데이트
                    video.style.display = 'none';
                    accessCameraBtn.style.display = 'none';
                    captureBtn.style.display = 'none';
                    retakeBtn.style.display = 'inline-block';
                    analyzeBtn.style.display = 'inline-block';
                    improveImageBtn.style.display = 'inline-block';
                    rotateButtons.style.display = 'flex';
                    
                    // 명함 감지 가이드 숨기기
                    document.getElementById('cardScanningGuide').style.display = 'none';
                    
                    // 고급 모드면 고급 옵션 버튼 표시
                    if (isAdvancedMode) {
                        advancedBtn.style.display = 'inline-block';
                    }
                    
                    // 회전 각도 초기화
                    currentRotation = 0;
                    
                    // 처리 단계 표시
                    stepsIndicator.style.display = 'flex';
                    updateProcessingStep('preprocess');
                    
                    showStatus('이미지가 업로드되었습니다. 분석을 시작하려면 "명함 분석" 버튼을 클릭하세요.', 'success');
                    
                    // 업로드된 이미지에서 명함 경계 감지 시도
                    detectBusinessCardBoundaries(event.target.result)
                        .then(result => {
                            if (result.success) {
                                lastDetectionResult = result;
                                showStatus('명함이 감지되었습니다. 분석 진행 시 경계를 기반으로 처리됩니다.', 'success');
                            }
                        })
                        .catch(error => {
                            console.error('업로드 이미지 명함 감지 오류:', error);
                        });
                };
                
                reader.onerror = (error) => {
                    console.error('파일 읽기 오류:', error);
                    showStatus('파일을 읽는 중 오류가 발생했습니다.', 'error');
                };
                
                reader.readAsDataURL(file);
            }
        });
        
        // 상태 메시지 표시 함수
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            
            // 기존 클래스 제거
            statusMessage.classList.remove('info', 'success', 'error');
            
            // 새 클래스 추가
            statusMessage.classList.add(type);
            
            // 메시지 표시
            statusMessage.style.display = 'block';
            
            // 성공 메시지는 3초 후 자동으로 숨김
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 3000);
            }
        }
        
        // 명함 데이터 로컬 스토리지에서 불러오기
        function loadBusinessCards() {
            try {
                const savedCards = localStorage.getItem('businessCards');
                
                if (savedCards) {
                    businessCards = JSON.parse(savedCards);
                    renderCardList();
                }
            } catch (error) {
                console.error('저장된 명함 로드 오류:', error);
                showStatus('저장된 명함을 불러오는 중 오류가 발생했습니다.', 'error');
                businessCards = []; // 오류 시 빈 배열로 초기화
            }
        }
        
        // 명함 데이터 로컬 스토리지에 저장
        function saveBusinessCards() {
            try {
                localStorage.setItem('businessCards', JSON.stringify(businessCards));
            } catch (error) {
                console.error('명함 저장 오류:', error);
                showStatus('명함 저장 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // 데이터 내보내기 함수
        function exportData() {
            try {
                const dataStr = JSON.stringify(businessCards, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'business_cards_' + new Date().toISOString().slice(0, 10) + '.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showStatus('데이터 내보내기 완료!', 'success');
            } catch (error) {
                console.error('데이터 내보내기 오류:', error);
                showStatus('데이터 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // 가져오기 모달 열기 함수
        function openImportModal() {
            importData.value = '';
            importModal.style.display = 'block';
        }
        
        // JSON 데이터 가져오기 함수
        function importDataFromJson() {
            try {
                const jsonData = importData.value.trim();
                
                if (!jsonData) {
                    throw new Error('가져올 데이터가 없습니다.');
                }
                
                const parsedData = JSON.parse(jsonData);
                
                if (!Array.isArray(parsedData)) {
                    throw new Error('유효하지 않은 데이터 형식입니다. JSON 배열이 필요합니다.');
                }
                
                if (confirm('기존 데이터를 새 데이터로 대체하시겠습니까? "취소"를 선택하면 기존 데이터에 추가됩니다.')) {
                    // 기존 데이터 대체
                    businessCards = parsedData;
                } else {
                    // 기존 데이터에 추가
                    businessCards = businessCards.concat(parsedData);
                }
                
                // 데이터 저장 및 목록 새로고침
                saveBusinessCards();
                renderCardList();
                
                // 모달 닫기
                importModal.style.display = 'none';
                
                showStatus(`${parsedData.length}개의 명함 데이터를 가져왔습니다.`, 'success');
            } catch (error) {
                console.error('데이터 가져오기 오류:', error);
                showStatus(`데이터 가져오기 오류: ${error.message}`, 'error');
            }
        }
        
        // 모든 데이터 초기화 함수
        function clearAllData() {
            if (confirm('모든 명함 데이터를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                businessCards = [];
                saveBusinessCards();
                renderCardList();
                showStatus('모든 명함 데이터가 삭제되었습니다.', 'success');
            }
        }
        
        // 명함 목록 렌더링
        function renderCardList(filterText = '') {
            let filteredCards = businessCards;
            
            // 검색어가 있으면 필터링
            if (filterText) {
                const searchTerms = filterText.toLowerCase().split(' ');
                
                filteredCards = businessCards.filter(card => {
                    const cardText = (
                        (card.name || '') + ' ' + 
                        (card.company || '') + ' ' + 
                        (card.position || '') + ' ' + 
                        (card.department || '') + ' ' + 
                        (card.phone || '') + ' ' + 
                        (card.email || '') + ' ' + 
                        (card.website || '') + ' ' + 
                        (card.address || '') + ' ' + 
                        (card.notes || '')
                    ).toLowerCase();
                    
                    return searchTerms.every(term => cardText.includes(term));
                });
            }
            
            // 빈 상태 처리
            if (filteredCards.length === 0) {
                cardList.innerHTML = '';
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
                
                cardList.innerHTML = filteredCards.map((card, index) => `
                    <div class="card-item" data-id="${card.id}">
                        <h3>${card.name || '이름 없음'}</h3>
                        <div class="card-details">
                            <p><strong>회사:</strong> ${card.company || '-'}</p>
                            <p><strong>직책:</strong> ${card.position || '-'}</p>
                            <p><strong>부서:</strong> ${card.department || '-'}</p>
                            <p><strong>전화:</strong> ${card.phone || '-'}</p>
                            <p><strong>이메일:</strong> ${card.email || '-'}</p>
                            ${card.website ? `<p><strong>웹사이트:</strong> ${card.website}</p>` : ''}
                            <p><strong>주소:</strong> ${card.address || '-'}</p>
                            <p><strong>등록일:</strong> ${new Date(card.registeredDate).toLocaleDateString()}</p>
                            ${card.notes ? `<p><strong>메모:</strong> ${card.notes}</p>` : ''}
                        </div>
                        <div class="card-actions">
                            <button class="edit-btn" data-id="${card.id}">수정</button>
                            <button class="delete-btn" data-id="${card.id}">삭제</button>
                        </div>
                    </div>
                `).join('');
                
                // 수정 버튼 이벤트 연결
                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.target.getAttribute('data-id');
                        openEditModal(id);
                    });
                });
                
                // 삭제 버튼 이벤트 연결
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.target.getAttribute('data-id');
                        deleteBusinessCard(id);
                    });
                });
            }
        }
        
        // 검색 기능
        searchInput.addEventListener('input', (e) => {
            renderCardList(e.target.value);
        });
        
        // 명함 외곽 인식 및 품질 판단 함수
        async function detectBusinessCardBoundaries(imageUrl) {
            return new Promise((resolve, reject) => {
                try {
                    if (!isOpencvReady) {
                        resolve({
                            success: false,
                            message: "OpenCV가 준비되지 않았습니다. 기본 모드로 진행합니다.",
                            qualityIssues: []
                        });
                        return;
                    }
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        try {
                            // 1. 이미지를 Mat으로 로드
                            const src = cv.imread(img);
                            const width = src.cols;
                            const height = src.rows;
                            
                            // 중간 결과물 저장용 캔버스 생성
                            const debugCanvas = document.createElement('canvas');
                            debugCanvas.width = width;
                            debugCanvas.height = height;
                            
                            // 품질 이슈 목록
                            const qualityIssues = [];
                            
                            // 2. 그레이스케일 변환
                            const gray = new cv.Mat();
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                            
                            // 3. 밝기 및 대비 분석
                            const mean = cv.mean(gray);
                            const brightness = mean[0]; // 평균 밝기
                            
                            let brightnessProblem = false;
                            if (brightness < 50) {
                                brightnessProblem = true;
                                qualityIssues.push({
                                    type: "brightness_low",
                                    message: "이미지가 너무 어둡습니다. 밝은 곳에서 촬영해주세요.",
                                    severity: "high"
                                });
                            } else if (brightness > 200) {
                                brightnessProblem = true;
                                qualityIssues.push({
                                    type: "brightness_high",
                                    message: "이미지가 너무 밝습니다. 노출을 줄이고 다시 촬영해주세요.",
                                    severity: "high"
                                });
                            }
                            
                            // 대비 분석 (표준편차 계산)
                            let stdDev = new cv.Mat();
                            let mean_stdDev = new cv.Mat();
                            cv.meanStdDev(gray, mean_stdDev, stdDev);
                            const contrast = stdDev.data64F[0];
                            
                            if (contrast < 30) {
                                qualityIssues.push({
                                    type: "contrast_low",
                                    message: "이미지 대비가 낮습니다. 명함과 배경의 색상 차이가 큰 환경에서 촬영해주세요.",
                                    severity: "medium"
                                });
                            }
                            
                            // 4. 가우시안 블러 적용 (노이즈 제거)
                            const blurred = new cv.Mat();
                            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                            
                            // 5. 캐니 엣지 검출
                            const edges = new cv.Mat();
                            cv.Canny(blurred, edges, 75, 200);
                            
                            // 엣지 디버그용 이미지
                            const edgeCanvas = document.createElement('canvas');
                            cv.imshow(edgeCanvas, edges);
                            
                            // 6. 엣지 강화 (팽창)
                            const dilated = new cv.Mat();
                            const M = cv.Mat.ones(3, 3, cv.CV_8U);
                            cv.dilate(edges, dilated, M);
                            
                            // 7. 컨투어 찾기
                            const contours = new cv.MatVector();
                            const hierarchy = new cv.Mat();
                            cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                            
                            // 8. 가장 큰 컨투어 찾기 (명함 후보)
                            let maxArea = 0;
                            let maxContourIndex = -1;
                            
                            for (let i = 0; i < contours.size(); ++i) {
                                const contour = contours.get(i);
                                const area = cv.contourArea(contour);
                                
                                // 너무 작은 컨투어는 무시 (노이즈 제거)
                                if (area > 1000) {
                                    if (area > maxArea) {
                                        maxArea = area;
                                        maxContourIndex = i;
                                    }
                                }
                            }
                            
                            // 9. 분석 결과 준비
                            let result = {
                                success: false,
                                message: "명함을 감지할 수 없습니다. 명함이 프레임 내에 완전히 보이도록 다시 촬영해주세요.",
                                qualityIssues: qualityIssues,
                                debugImage: edgeCanvas.toDataURL('image/png', 0.7)
                            };
                            
                            // 전체 이미지 크기 대비 컨투어 크기 비율
                            const totalImageArea = width * height;
                            
                            // 10. 명함 컨투어가 발견된 경우
                            if (maxContourIndex >= 0) {
                                const cardContour = contours.get(maxContourIndex);
                                
// 최소 사각형 얻기
const rotatedRect = cv.minAreaRect(cardContour);
let cornerPointsData;
try {
    cornerPointsData = cv.boxPoints(rotatedRect);
} catch (e) {
    // 대체 함수 사용
    cornerPointsData = boxPoints(rotatedRect);
}

// 회전된 사각형의 네 꼭지점 좌표
const cardCorners = [];
for (let i = 0; i < 4; i++) {
    cardCorners.push({
        x: cornerPointsData.data32F[i*2],
        y: cornerPointsData.data32F[i*2+1]
    });
}
                                
                                // 명함 크기 계산
                                const boxWidth = rotatedRect.size.width;
                                const boxHeight = rotatedRect.size.height;
                                const cardArea = boxWidth * boxHeight;
                                const cardRatio = cardArea / totalImageArea;
                                
                                // 명함 비율 확인 (명함은 보통 가로세로 비율이 1.5~1.8 정도)
                                const widthHeightRatio = Math.max(boxWidth, boxHeight) / Math.min(boxWidth, boxHeight);
                                
                                // 결과 캔버스에 명함 외곽선 그리기
                                const visualizedResult = new cv.Mat.zeros(height, width, cv.CV_8UC4);
                                
                                // 원본 이미지 복사
                                src.copyTo(visualizedResult);
                                
                                // 컨투어 그리기
                                const contourColor = new cv.Scalar(0, 255, 0, 255); // 녹색
                                const thickness = 3;
                                const fourPoints = new cv.Mat(4, 1, cv.CV_32SC2);
                                
// 박스 포인트를 정수형으로 변환
for (let i = 0; i < 4; i++) {
    fourPoints.data32S[i*2] = Math.round(cornerPointsData.data32F[i*2]);
    fourPoints.data32S[i*2+1] = Math.round(cornerPointsData.data32F[i*2+1]);
}
                                
                                // 사각형 그리기
                                for (let i = 0; i < 4; i++) {
                                    cv.line(
                                        visualizedResult,
                                        new cv.Point(fourPoints.data32S[i*2], fourPoints.data32S[i*2+1]),
                                        new cv.Point(fourPoints.data32S[((i+1)%4)*2], fourPoints.data32S[((i+1)%4)*2+1]),
                                        contourColor,
                                        thickness
                                    );
                                }
                                
                                // 꼭지점에 원 그리기
                                for (let i = 0; i < 4; i++) {
                                    cv.circle(
                                        visualizedResult,
                                        new cv.Point(fourPoints.data32S[i*2], fourPoints.data32S[i*2+1]),
                                        7,
                                        new cv.Scalar(255, 0, 0, 255), // 빨간색
                                        -1 // 채우기
                                    );
                                }
                                
                                // 품질 이슈 추가
                                
                                // 1. 명함 비율 확인
                                if (widthHeightRatio < 1.3 || widthHeightRatio > 1.9) {
                                    qualityIssues.push({
                                        type: "card_ratio_abnormal",
                                        message: "명함의 형태가 일반적이지 않습니다. 명함이 카메라와 평행하게 놓여있는지 확인해주세요.",
                                        severity: "medium"
                                    });
                                }
                                
                                // 2. 명함 크기 확인 (화면 대비)
                                if (cardRatio < 0.2) {
                                    qualityIssues.push({
                                        type: "card_too_small",
                                        message: "명함이 너무 작게 보입니다. 카메라를 명함에 더 가까이 대주세요.",
                                        severity: "high"
                                    });
                                } else if (cardRatio > 0.9) {
                                    qualityIssues.push({
                                        type: "card_too_large",
                                        message: "명함이 너무 크게 보입니다. 전체 명함이 화면에 들어오도록 조정해주세요.",
                                        severity: "high"
                                    });
                                }
                                
                                // 3. 명함 위치 확인 (중앙에 있는지)
                                const centerX = width / 2;
                                const centerY = height / 2;
                                
                                // 명함 중앙점 계산
                                let cardCenterX = 0;
                                let cardCenterY = 0;
                                
                                for (let i = 0; i < 4; i++) {
                                    cardCenterX += fourPoints.data32S[i*2];
                                    cardCenterY += fourPoints.data32S[i*2+1];
                                }
                                cardCenterX /= 4;
                                cardCenterY /= 4;
                                
                                // 중앙점 편차 계산
                                const distFromCenter = Math.sqrt(
                                    Math.pow(cardCenterX - centerX, 2) + 
                                    Math.pow(cardCenterY - centerY, 2)
                                );
                                
                                // 중앙에서 20% 이상 벗어나면 경고
                                if (distFromCenter > width * 0.2) {
                                    qualityIssues.push({
                                        type: "card_not_centered",
                                        message: "명함이 중앙에 위치하지 않았습니다. 명함을 화면 중앙에 맞춰주세요.",
                                        severity: "medium"
                                    });
                                }
                                
                                // 4. 모서리가 화면 바깥으로 나갔는지 확인
                                let cornersOutside = false;
                                for (let i = 0; i < 4; i++) {
                                    const x = fourPoints.data32S[i*2];
                                    const y = fourPoints.data32S[i*2+1];
                                    
                                    if (x <= 5 || x >= width-5 || y <= 5 || y >= height-5) {
                                        cornersOutside = true;
                                        break;
                                    }
                                }
                                
                                if (cornersOutside) {
                                    qualityIssues.push({
                                        type: "card_outside_frame",
                                        message: "명함의 일부가 화면 밖으로 나갔습니다. 전체 명함이 화면에 들어오도록 조정해주세요.",
                                        severity: "high"
                                    });
                                }
                                
                                // 5. 초점 흐림 확인 (라플라시안 필터를 사용한 변량 측정)
                                const laplacian = new cv.Mat();
                                cv.Laplacian(gray, laplacian, cv.CV_64F);
                                let laplacianMean = new cv.Mat();
                                let laplacianStdDev = new cv.Mat();
                                cv.meanStdDev(laplacian, laplacianMean, laplacianStdDev);
                                const variance = laplacianStdDev.data64F[0] * laplacianStdDev.data64F[0];
                                
                                if (variance < 100) {
                                    qualityIssues.push({
                                        type: "image_blurry",
                                        message: "이미지가 흐릿합니다. 카메라 초점을 명함에 맞추고 흔들림 없이 촬영해주세요.",
                                        severity: "high"
                                    });
                                }
                                
                                // 비주얼 결과 출력
                                cv.imshow(debugCanvas, visualizedResult);
                                
                                // 결과 반환
                                result = {
                                    success: true,
                                    message: qualityIssues.length > 0 
                                        ? "명함이 감지되었지만 몇 가지 품질 문제가 있습니다." 
                                        : "명함이 정상적으로 감지되었습니다.",
                                    corners: cardCorners,
                                    angle: rotatedRect.angle,
                                    width: boxWidth,
                                    height: boxHeight,
                                    area: cardArea,
                                    ratio: widthHeightRatio,
                                    qualityIssues: qualityIssues,
                                    visualizedImage: debugCanvas.toDataURL('image/png', 0.8),
                                    debugImage: edgeCanvas.toDataURL('image/png', 0.7)
                                };
                                
                                // 메모리 해제
                                fourPoints.delete();
                                laplacian.delete();
                                laplacianMean.delete();
                                laplacianStdDev.delete();
                            } else {
                                // 명함이 발견되지 않은 경우
                                qualityIssues.push({
                                    type: "no_card_detected",
                                    message: "명함을 감지할 수 없습니다. 밝은 배경에 명함을 놓고 다시 시도해주세요.",
                                    severity: "critical"
                                });
                            }
                            
                            // 메모리 해제
                            src.delete();
                            gray.delete();
                            blurred.delete();
                            edges.delete();
                            dilated.delete();
                            contours.delete();
                            hierarchy.delete();
                            stdDev.delete();
                            mean_stdDev.delete();
                            M.delete();
                            
                            resolve(result);
                            
                        } catch (error) {
                            console.error('명함 외곽선 감지 중 오류:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = function(error) {
                        reject(new Error('이미지 로딩에 실패했습니다.'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('명함 감지 초기화 오류:', error);
                    reject(error);
                }
            });
        }
        
        // 실시간 명함 감지 시작 함수
        function startRealTimeCardDetection() {
            if (isCardDetectionActive) return;
            
            isCardDetectionActive = true;
            
            // 명함 감지 가이드 표시
            const cardGuide = document.getElementById('cardScanningGuide');
            cardGuide.style.display = 'block';
            
            // 감지 타이머 설정 (200ms 간격)
            cardDetectionTimer = setInterval(async () => {
                if (!video.srcObject || video.paused || video.ended) {
                    // 비디오가 재생 중이 아니면 감지 중지
                    stopRealTimeCardDetection();
                    return;
                }
                
                try {
                    // 현재 프레임을 캔버스에 그리기
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // 캔버스 이미지 데이터를 URL로 변환
                    const imageData = canvas.toDataURL('image/jpeg', 0.7);
                    
                    // 명함 외곽선 감지
                    const result = await detectBusinessCardBoundaries(imageData);
                    lastDetectionResult = result;
                    
                    // 품질 지표 업데이트
                    updateQualityIndicators(result);
                    
                    // 감지 결과에 따라 안내 메시지 및 가이드 업데이트
                    updateDetectionGuide(result);
                    
                } catch (error) {
                    console.error('실시간 명함 감지 오류:', error);
                }
            }, 200); // 200ms 간격으로 감지 (성능과 정확도의 균형)
        }
        
        // 실시간 명함 감지 중지 함수
function stopRealTimeCardDetection() {
            if (!isCardDetectionActive) return;
            
            // 타이머 중지
            if (cardDetectionTimer) {
                clearInterval(cardDetectionTimer);
                cardDetectionTimer = null;
            }
            
            isCardDetectionActive = false;
            
            // 명함 가이드 숨기기
            const cardGuide = document.getElementById('cardScanningGuide');
            cardGuide.style.display = 'none';
        }
        
        // 품질 지표 업데이트 함수
        function updateQualityIndicators(result) {
            if (!result) return;
            
            const brightnessIndicator = document.getElementById('brightnessIndicator');
            const sharpnessIndicator = document.getElementById('sharpnessIndicator');
            const alignmentIndicator = document.getElementById('alignmentIndicator');
            
            const brightnessValue = document.getElementById('brightnessValue');
            const sharpnessValue = document.getElementById('sharpnessValue');
            const alignmentValue = document.getElementById('alignmentValue');
            
            // 품질 상세 정보 업데이트
            const qualityDetailsList = document.getElementById('qualityDetailsList');
            
            if (result.success) {
                // 품질 지표 계산
                let brightnessScore = 100;
                let sharpnessScore = 100;
                let alignmentScore = 100;
                
                // 품질 이슈에 따른 점수 조정
                result.qualityIssues.forEach(issue => {
                    if (issue.type.includes('brightness')) {
                        brightnessScore -= (issue.severity === 'critical' ? 80 : 
                                          issue.severity === 'high' ? 50 : 
                                          issue.severity === 'medium' ? 30 : 10);
                    } else if (issue.type.includes('blurry')) {
                        sharpnessScore -= (issue.severity === 'critical' ? 80 : 
                                         issue.severity === 'high' ? 50 : 
                                         issue.severity === 'medium' ? 30 : 10);
                    } else if (issue.type.includes('card_not_centered') || 
                             issue.type.includes('card_outside_frame') ||
                             issue.type.includes('card_ratio')) {
                        alignmentScore -= (issue.severity === 'critical' ? 80 : 
                                        issue.severity === 'high' ? 50 : 
                                        issue.severity === 'medium' ? 30 : 10);
                    }
                });
                
                // 점수 범위 조정 (0-100)
                brightnessScore = Math.max(0, Math.min(100, brightnessScore));
                sharpnessScore = Math.max(0, Math.min(100, sharpnessScore));
                alignmentScore = Math.max(0, Math.min(100, alignmentScore));
                
                // 지표 표시 업데이트
                brightnessIndicator.style.width = `${brightnessScore}%`;
                sharpnessIndicator.style.width = `${sharpnessScore}%`;
                alignmentIndicator.style.width = `${alignmentScore}%`;
                
                brightnessValue.textContent = `${brightnessScore}%`;
                sharpnessValue.textContent = `${sharpnessScore}%`;
                alignmentValue.textContent = `${alignmentScore}%`;
                
                // 색상 업데이트
                brightnessIndicator.style.backgroundColor = getColorForScore(brightnessScore);
                sharpnessIndicator.style.backgroundColor = getColorForScore(sharpnessScore);
                alignmentIndicator.style.backgroundColor = getColorForScore(alignmentScore);
                
                // 품질 상세 정보 업데이트
                qualityDetailsList.innerHTML = '';
                if (result.qualityIssues.length > 0) {
                    result.qualityIssues.forEach(issue => {
                        const issueItem = document.createElement('div');
                        issueItem.style.marginBottom = '5px';
                        
                        // 심각도에 따른 색상
                        const severityColor = 
                            issue.severity === 'critical' ? '#dc3545' :
                            issue.severity === 'high' ? '#ffc107' : 
                            issue.severity === 'medium' ? '#fd7e14' : '#28a745';
                        
                        issueItem.innerHTML = `
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: ${severityColor}; border-radius: 50%; margin-right: 5px;"></span>
                            ${issue.message}
                        `;
                        qualityDetailsList.appendChild(issueItem);
                    });
                } else {
                    qualityDetailsList.innerHTML = '<div style="color: #28a745;">명함 품질이 우수합니다. 촬영해주세요!</div>';
                }
                
                // 조명 상태 아이콘 업데이트
                updateLightingIndicator(brightnessScore);
                
            } else {
                // 감지 실패 시 모든 지표 낮게 설정
                brightnessIndicator.style.width = '30%';
                sharpnessIndicator.style.width = '30%';
                alignmentIndicator.style.width = '30%';
                
                brightnessValue.textContent = '30%';
                sharpnessValue.textContent = '30%';
                alignmentValue.textContent = '30%';
                
                brightnessIndicator.style.backgroundColor = '#dc3545';
                sharpnessIndicator.style.backgroundColor = '#dc3545';
                alignmentIndicator.style.backgroundColor = '#dc3545';
                
                // 품질 상세 정보 업데이트
                qualityDetailsList.innerHTML = '<div style="color: #dc3545;">명함이 감지되지 않았습니다. 명함을 가이드 영역에 맞춰주세요.</div>';
                
                // 이슈가 있다면 추가
                if (result.qualityIssues && result.qualityIssues.length > 0) {
                    result.qualityIssues.forEach(issue => {
                        const issueItem = document.createElement('div');
                        issueItem.style.marginBottom = '5px';
                        issueItem.innerHTML = `
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #dc3545; border-radius: 50%; margin-right: 5px;"></span>
                            ${issue.message}
                        `;
                        qualityDetailsList.appendChild(issueItem);
                    });
                }
                
                // 조명 상태 아이콘 업데이트
                updateLightingIndicator(30);
            }
        }
        
        // 점수에 따른 색상 반환 함수
        function getColorForScore(score) {
            if (score >= 80) return '#28a745'; // 녹색 (좋음)
            if (score >= 60) return '#fd7e14'; // 주황색 (보통)
            if (score >= 40) return '#ffc107'; // 노란색 (주의)
            return '#dc3545'; // 빨간색 (나쁨)
        }
        
        // 조명 상태 아이콘 업데이트 함수
        function updateLightingIndicator(brightnessScore) {
            const lightingIndicator = document.getElementById('lightingIndicator');
            
            if (brightnessScore >= 80) {
                lightingIndicator.textContent = '💡'; // 적정 밝기
                lightingIndicator.style.backgroundColor = 'rgba(40, 167, 69, 0.7)';
            } else if (brightnessScore >= 50) {
                lightingIndicator.textContent = '🔆'; // 조금 어두움
                lightingIndicator.style.backgroundColor = 'rgba(255, 193, 7, 0.7)';
            } else if (brightnessScore >= 20) {
                lightingIndicator.textContent = '🔅'; // 매우 어두움
                lightingIndicator.style.backgroundColor = 'rgba(220, 53, 69, 0.7)';
            } else {
                lightingIndicator.textContent = '🕯️'; // 극도로 어두움
                lightingIndicator.style.backgroundColor = 'rgba(220, 53, 69, 0.7)';
            }
        }
        
        // 감지 결과에 따른 가이드 업데이트 함수
        function updateDetectionGuide(result) {
            const guideText = document.getElementById('cardDetectionGuide');
            const autoCapture = document.getElementById('autoCaptureBtn');
            
            if (!result) {
                guideText.textContent = "명함을 가이드 영역에 맞춰주세요";
                guideText.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                autoCapture.style.display = 'none';
                return;
            }
            
            if (result.success) {
                // 명함이 감지됨
                if (result.qualityIssues.length > 0) {
                    // 품질 이슈가 있는 경우
                    // 가장 심각한 문제 찾기
                    const criticalIssues = result.qualityIssues.filter(issue => issue.severity === 'critical');
                    const highIssues = result.qualityIssues.filter(issue => issue.severity === 'high');
                    const mediumIssues = result.qualityIssues.filter(issue => issue.severity === 'medium');
                    
                    let mainIssue = criticalIssues[0] || highIssues[0] || mediumIssues[0];
                    
                    if (mainIssue) {
                        guideText.textContent = mainIssue.message;
                        guideText.style.backgroundColor = 
                            mainIssue.severity === 'critical' ? 'rgba(220, 53, 69, 0.8)' : 
                            mainIssue.severity === 'high' ? 'rgba(255, 193, 7, 0.8)' : 
                            'rgba(40, 167, 69, 0.8)';
                        
                        // 심각한 이슈가 있으면 자동 캡처 버튼 숨김
                        if (mainIssue.severity === 'critical' || mainIssue.severity === 'high') {
                            autoCapture.style.display = 'none';
                        } else {
                            autoCapture.style.display = 'block';
                        }
                    } else {
                        // 경미한 이슈만 있는 경우
                        guideText.textContent = "명함이 감지되었습니다. 촬영 버튼을 눌러주세요.";
                        guideText.style.backgroundColor = 'rgba(40, 167, 69, 0.8)';
                        autoCapture.style.display = 'block';
                    }
                } else {
                    // 품질 문제가 없는 경우
                    guideText.textContent = "완벽합니다! 촬영 버튼을 눌러주세요.";
                    guideText.style.backgroundColor = 'rgba(40, 167, 69, 0.8)';
                    autoCapture.style.display = 'block';
                }
            } else {
                // 명함이 감지되지 않음
                guideText.textContent = result.message || "명함을 감지할 수 없습니다. 조명을 확인하고 다시 시도해주세요.";
                guideText.style.backgroundColor = 'rgba(220, 53, 69, 0.8)';
                autoCapture.style.display = 'none';
            }
        }
        
        // 명함 카드 감지 함수 토글 - 설정 페이지에 추가
        function addCardDetectionToggle() {
            // 설정 폼에 토글 추가
            const settingsForm = document.querySelector('#settingsContent .card-form');
            
            // 이미 존재하는지 확인
            if (document.getElementById('cardDetectionToggle')) return;
            
            const detectionToggleDiv = document.createElement('div');
            detectionToggleDiv.className = 'form-group';
            detectionToggleDiv.innerHTML = `
                <label>
                    <input type="checkbox" id="cardDetectionToggle" ${realTimeBoundaryDetection ? 'checked' : ''}>
                    실시간 명함 감지 사용 (고급 인식 기능)
                </label>
                <p style="font-size: 12px; color: #6c757d;">명함을 실시간으로 감지하고 최적의 촬영 상태를 안내합니다.</p>
            `;
            
            // 첫 번째 설정 항목 앞에 삽입
            settingsForm.insertBefore(detectionToggleDiv, settingsForm.firstChild);
            
            // 토글 이벤트 설정
            document.getElementById('cardDetectionToggle').addEventListener('change', function() {
                realTimeBoundaryDetection = this.checked;
                // 로컬 스토리지에 설정 저장
                appSettings.realTimeBoundaryDetection = realTimeBoundaryDetection;
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
            });
        }
        
        // 명함 이미지 퍼스펙티브 변환 함수
        async function perspectiveTransformCard(imageUrl, corners) {
            return new Promise((resolve, reject) => {
                try {
                    if (!isOpencvReady) {
                        resolve(imageUrl); // OpenCV가 없으면 원본 반환
                        return;
                    }
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        try {
                            // 이미지를 Mat으로 로드
                            const src = cv.imread(img);
                            
// 소스 포인트 (감지된 명함 모서리)
// corners 배열이 유효한지 확인
if (!corners || corners.length !== 4) {
    resolve(imageUrl); // 유효하지 않은 경우 원본 반환
    return;
}

try {
    const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
        corners[0].x, corners[0].y,
        corners[1].x, corners[1].y,
        corners[2].x, corners[2].y,
        corners[3].x, corners[3].y
    ]);

    // 나머지 코드...
} catch (e) {
    console.error('투시 변환 매트릭스 생성 오류:', e);
    resolve(imageUrl); // 오류 시 원본 반환
}
                            
                            // 명함 표준 크기 (명함 비율 유지)
                            // 일반적인 명함 크기는 90mm x 55mm (가로 x 세로)
                            const standardWidth = 900;
                            const standardHeight = 550;
                            
                            // 대상 포인트 (변환 후 직사각형)
                            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                                0, 0,
                                standardWidth, 0,
                                standardWidth, standardHeight,
                                0, standardHeight
                            ]);
                            
                            // 투시 변환 행렬 계산
                            const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
                            
                            // 결과 이미지 생성
                            const dst = new cv.Mat();
                            cv.warpPerspective(src, dst, M, new cv.Size(standardWidth, standardHeight));
                            
                            // 결과 이미지를 캔버스에 그리기
                            const canvas = document.createElement('canvas');
                            canvas.width = standardWidth;
                            canvas.height = standardHeight;
                            cv.imshow(canvas, dst);
                            
                            // 변환된 이미지 URL 생성
                            const transformedImage = canvas.toDataURL('image/jpeg', 0.9);
                            
                            // 메모리 해제
                            src.delete();
                            dst.delete();
                            srcPoints.delete();
                            dstPoints.delete();
                            M.delete();
                            
                            // 결과 반환
                            resolve(transformedImage);
                            
                        } catch (error) {
                            console.error('투시 변환 오류:', error);
                            resolve(imageUrl); // 오류 시 원본 반환
                        }
                    };
                    
                    img.onerror = function() {
                        reject(new Error('이미지 로딩에 실패했습니다.'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('투시 변환 초기화 오류:', error);
                    resolve(imageUrl); // 오류 시 원본 반환
                }
            });
        }
        
        // 향상된 이미지 전처리 함수 (은행 OCR 품질)
        async function enhanceBusinessCardImageBankLevel(imageUrl, options = {}) {
            return new Promise((resolve, reject) => {
                try {
                    if (!isOpencvReady) {
                        // OpenCV가 없으면 기본 캔버스 처리 시도
                        return enhanceWithCanvas(imageUrl)
                            .then(enhanced => resolve(enhanced))
                            .catch(err => {
                                console.warn('캔버스 처리 실패, 원본 이미지 사용:', err);
                                resolve(imageUrl);
                            });
                    }
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        try {
                            // 1. 이미지를 Mat으로 로드
                            const src = cv.imread(img);
                            
                            // 2. 명함 외곽선 감지
                            detectBusinessCardBoundaries(imageUrl)
                                .then(async detectionResult => {
                                    try {
                                        let enhanced;
                                        
                                        if (detectionResult.success && detectionResult.corners) {
                                            // 명함이 감지되면 투시 변환 적용
                                            enhanced = await perspectiveTransformCard(imageUrl, detectionResult.corners);
                                            
                                            // 변환된 이미지를 다시 로드하여 추가 처리
                                            const transformedImg = new Image();
                                            transformedImg.onload = function() {
                                                try {
                                                    // 변환된 이미지 처리
                                                    const transformedSrc = cv.imread(transformedImg);
                                                    
                                                    // 추가 처리 (그레이스케일, 필터 등)
                                                    applyOcrOptimization(transformedSrc, options)
                                                        .then(optimizedImage => {
                                                            // 미리보기 추가
                                                            addPreview('은행 수준 처리', optimizedImage);
                                                            resolve(optimizedImage);
                                                        })
                                                        .catch(error => {
                                                            console.error('이미지 최적화 오류:', error);
                                                            resolve(enhanced); // 오류 시 투시 변환 이미지만 반환
                                                        })
                                                        .finally(() => {
                                                            // 메모리 해제
                                                            transformedSrc.delete();
                                                        });
                                                } catch (error) {
                                                    console.error('변환 이미지 처리 오류:', error);
                                                    resolve(enhanced);
                                                }
                                            };
                                            
                                            transformedImg.onerror = function() {
                                                console.error('변환 이미지 로드 오류');
                                                resolve(enhanced);
                                            };
                                            
                                            transformedImg.src = enhanced;
                                            
                                        } else {
                                            // 명함 감지 실패 시 기본 처리 적용
                                            applyOcrOptimization(src, options)
                                                .then(optimizedImage => {
                                                    // 미리보기 추가
                                                    addPreview('표준 OCR 최적화', optimizedImage);
                                                    resolve(optimizedImage);
                                                })
                                                .catch(error => {
                                                    console.error('이미지 최적화 오류:', error);
                                                    resolve(imageUrl);
                                                });
                                        }
                                    } catch (error) {
                                        console.error('감지 후처리 오류:', error);
                                        
                                        // 오류 발생 시 기본 처리 시도
                                        applyOcrOptimization(src, options)
                                            .then(optimizedImage => resolve(optimizedImage))
                                            .catch(() => resolve(imageUrl))
                                            .finally(() => {
                                                // 메모리 해제
                                                src.delete();
                                            });
                                    }
                                })
                                .catch(error => {
                                    console.error('명함 감지 오류:', error);
                                    
                                    // 감지 오류 시 기본 처리 적용
                                    applyOcrOptimization(src, options)
                                        .then(optimizedImage => resolve(optimizedImage))
                                        .catch(() => resolve(imageUrl))
                                        .finally(() => {
                                            // 메모리 해제
                                            src.delete();
                                        });
                                });
                        } catch (error) {
                            console.error('이미지 처리 초기화 오류:', error);
                            resolve(imageUrl); // 오류 시 원본 반환
                        }
                    };
                    
                    img.onerror = function() {
                        reject(new Error('이미지 로딩에 실패했습니다.'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('이미지 처리 초기화 오류:', error);
                    reject(error);
                }
            });
        }
        
        // OCR 최적화 이미지 처리 함수
        async function applyOcrOptimization(src, options = {}) {
            return new Promise((resolve, reject) => {
                try {
                    // 메모리 관리를 위한 Mat 객체 배열
                    const mats = [];
                    
                    // 작업용 Mat 생성
                    const gray = new cv.Mat();
                    mats.push(gray);
                    
                    // 1. 그레이스케일 변환
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    
                    // 2. 이미지 정규화 (명함 이미지의 밝기 및 대비 향상)
                    const normalized = new cv.Mat();
                    mats.push(normalized);
                    cv.normalize(gray, normalized, 0, 255, cv.NORM_MINMAX);
                    
                    // 3. 잡음 제거
                    const denoised = new cv.Mat();
                    mats.push(denoised);
                    cv.fastNlMeansDenoising(normalized, denoised, 10, 7, 21);
                    
                    // 4. 언샤프 마스킹 (선명도 향상)
                    const blurred = new cv.Mat();
                    mats.push(blurred);
                    cv.GaussianBlur(denoised, blurred, new cv.Size(0, 0), 3);
                    
                    const sharpened = new cv.Mat();
                    mats.push(sharpened);
                    const alpha = 1.5;
                    const beta = 1.0 - alpha;
                    cv.addWeighted(denoised, alpha, blurred, beta, 0, sharpened);
                    
                    // 5. CLAHE (Contrast Limited Adaptive Histogram Equalization)
                    const enhanced = new cv.Mat();
                    mats.push(enhanced);
                    
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(sharpened, enhanced);
                    
                    // 6. Otsu 또는 적응형 이진화 (옵션에 따라)
                    let processedImage;
                    
                    if (options.binarize) {
                        const binary = new cv.Mat();
                        mats.push(binary);
                        
                        if (options.adaptiveThreshold) {
                            // 적응형 이진화
                            cv.adaptiveThreshold(
                                enhanced,
                                binary,
                                255,
                                cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                                cv.THRESH_BINARY,
                                11,
                                2
                            );
                        } else {
                            // Otsu 이진화
                            cv.threshold(enhanced, binary, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
                        }
                        processedImage = binary;
                    } else {
                        processedImage = enhanced;
                    }
                    
                    // 7. 결과 캔버스에 그리기
                    const canvas = document.createElement('canvas');
                    canvas.width = processedImage.cols;
                    canvas.height = processedImage.rows;
                    cv.imshow(canvas, processedImage);
                    
                    // 8. 이미지 URL 생성
                    const finalImageUrl = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // 9. 메모리 해제
                    mats.forEach(mat => mat.delete());
                    
                    // 10. 결과 반환
                    resolve(finalImageUrl);
                    
                } catch (error) {
                    console.error('OCR 최적화 처리 오류:', error);
                    reject(error);
                }
            });
        }
        
        // 기본 캔버스 API로 간단한 이미지 개선
        async function enhanceWithCanvas(imageUrl) {
            return new Promise((resolve, reject) => {
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            
                            // 원본 이미지 그리기
                            ctx.drawImage(img, 0, 0);
                            
                            // 이미지 데이터 가져오기
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;
                            
                            // 그레이스케일 및 대비 향상
                            for (let i = 0; i < data.length; i += 4) {
                                // 그레이스케일 변환
                                const gray = (data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11);
                                
                                // 대비 향상 (간단한 방식)
                                const contrast = 1.5;
                                const brightness = 10;
                                const enhanced = Math.min(255, Math.max(0, (gray - 128) * contrast + 128 + brightness));
                                
                                data[i] = data[i + 1] = data[i + 2] = enhanced;
                            }
                            
                            // 변경된 이미지 데이터 적용
                            ctx.putImageData(imageData, 0, 0);
                            
                            // 결과 URL 생성
                            const resultUrl = canvas.toDataURL('image/png', parseFloat(appSettings.imageQuality || 0.8));
                            
                            // 미리보기 추가
                            addPreview('기본 개선', resultUrl);
                            
                            resolve(resultUrl);
                        } catch (e) {
                            console.error('캔버스 처리 오류:', e);
                            resolve(imageUrl); // 오류 시 원본 반환
                        }
                    };
                    
                    img.onerror = function() {
                        reject(new Error('이미지 로딩 실패'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('캔버스 처리 초기화 오류:', error);
                    reject(error);
                }
            });
        }
        
        // 전처리 옵션 가져오기
        function getPreprocessingOptions() {
            return {
                grayscale: document.getElementById('optGrayscale').checked,
                adaptiveThreshold: document.getElementById('optAdaptiveThreshold').checked,
                contrast: document.getElementById('optContrast').checked,
                sharpen: document.getElementById('optSharpen').checked,
                denoise: document.getElementById('optDenoise').checked,
                threshold: document.getElementById('optThreshold').checked,
                edgeEnhance: document.getElementById('optEdgeEnhance').checked,
                deskew: document.getElementById('optDeskew').checked
            };
        }
        
        // 이미지 전처리 적용
        function applyPreprocessing() {
            if (!originalImageData) {
                showStatus('이미지가 없습니다. 먼저 명함을 촬영해주세요.', 'error');
                return;
            }
            
            showStatus('이미지 처리 중...', 'info');
            
            const options = getPreprocessingOptions();
            
            // 이미지 전처리 실행
            enhanceBusinessCardImage(originalImageData, options)
                .then(enhancedImage => {
                    capturedImage.src = enhancedImage;
                    showStatus('이미지 처리 완료!', 'success');
                    
                    // 미리보기 추가
                    addPreview('고급 처리', enhancedImage);
                })
                .catch(error => {
                    console.error('이미지 처리 오류:', error);
                    showStatus('이미지 처리 중 오류가 발생했습니다.', 'error');
                });
        }
        
        // OpenCV를 사용한 명함 이미지 전처리 함수
        async function enhanceBusinessCardImage(imageUrl, options = {}) {
            return new Promise((resolve, reject) => {
                try {
                    if (!isOpencvReady) {
                        reject(new Error('OpenCV.js가 아직 로드되지 않았습니다.'));
                        return;
                    }
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        try {
                            // 1. 이미지를 Mat으로 로드
                            const src = cv.imread(img);
                            
                            // 2. 작업용 Mat 생성
                            let dst = new cv.Mat();
                            let gray = new cv.Mat();
                            let blur = new cv.Mat();
                            let edges = new cv.Mat();
                            let processed = new cv.Mat();
                            
                            try {
                                // 3. 그레이스케일 변환 (필수 단계)
                                if (options.grayscale) {
                                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                                } else {
                                    src.copyTo(gray);
                                }
                                
                                // 4. 노이즈 제거 (옵션)
                                if (options.denoise) {
                                    // 비로컬 평균 필터
// 비로컬 평균 필터
safeNlMeansDenoising(gray, blur, 10, 7, 21);
                                } else {
                                    gray.copyTo(blur);
                                }
                                
                                // 5. 명암 대비 향상 (옵션)
                                if (options.contrast) {
                                    // CLAHE(Contrast Limited Adaptive Histogram Equalization) 적용
                                    let clahe = new cv.CLAHE(4.0, new cv.Size(8, 8));
                                    clahe.apply(blur, processed);
                                    clahe.delete();
                                } else {
                                    blur.copyTo(processed);
                                }
                                
                                // 6. 선명도 향상 (옵션)
                                if (options.sharpen) {
                                    // 언샤프 마스크 처리
                                    let blurred = new cv.Mat();
                                    let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                                    let temp = new cv.Mat();
                                    
                                    // 블러 처리된 이미지
                                    cv.GaussianBlur(processed, blurred, new cv.Size(0, 0), 3);
                                    
                                    // 원본 - 블러 = 엣지
                                    cv.subtract(processed, blurred, temp);
                                    
                                    // 원본 + 엣지 = 선명한 이미지
                                    cv.add(processed, temp, processed);
                                    
                                    // 임시 Mat 정리
                                    blurred.delete();
                                    kernel.delete();
                                    temp.delete();
                                }
                                
                                // 7. 적응형 이진화 (옵션)
                                if (options.adaptiveThreshold) {
                                    let binary = new cv.Mat();
                                    cv.adaptiveThreshold(processed, binary, 255,
                                        cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                                    
                                    // 역상 변환 (텍스트를 검은색으로)
                                    cv.bitwise_not(binary, binary);
                                    binary.copyTo(processed);
                                    binary.delete();
                                }
                                
                                // 8. 일반 이진화 (옵션)
                                if (options.threshold) {
                                    let thresh = new cv.Mat();
                                    cv.threshold(processed, thresh, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
                                    thresh.copyTo(processed);
                                    thresh.delete();
                                }
                                
                                // 9. 엣지 강화 (옵션)
                                if (options.edgeEnhance) {
                                    let edges = new cv.Mat();
                                    // Canny 엣지 검출
                                    cv.Canny(processed, edges, 50, 150);
                                    
                                    // 엣지 두껍게
                                    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                                    cv.dilate(edges, edges, kernel);
                                    
                                    // 합성 (원본 + 엣지)
                                    if (options.adaptiveThreshold || options.threshold) {
                                        // 이진화된 이미지면 OR 연산
                                        cv.bitwise_or(processed, edges, processed);
                                    } else {
                                        // 그레이스케일 이미지면 엣지를 그냥 추가
                                        cv.add(processed, edges, processed);
                                    }
                                    
                                    edges.delete();
                                    kernel.delete();
                                }
                                
                                // 10. 기울기 보정 (옵션)
                                if (options.deskew) {
                                    try {
                                        // 엣지 검출
                                        cv.Canny(processed, edges, 50, 150);
                                        
                                        // 허프 변환으로 선 검출
                                        let lines = new cv.Mat();
                                        cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 50, 50, 10);
                                        
                                        if (lines.rows > 0) {
                                            // 각도 계산
                                            let angles = [];
                                            
                                            for (let i = 0; i < lines.rows; i++) {
                                                let line = lines.data32S.slice(i * 4, (i + 1) * 4);
                                                let [x1, y1, x2, y2] = line;
                                                
                                                // 너무 짧은 선은 건너뛰기
                                                let length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                                                if (length < 30) continue;
                                                
                                                // 각도 계산 (라디안 -> 도)
                                                let angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                                                
                                                // 수평선에 가까운 선만 사용 (-20° ~ 20° 또는 160° ~ 200°)
                                                if ((Math.abs(angle) < 20 || Math.abs(angle - 180) < 20)) {
                                                    angles.push(angle);
                                                }
                                            }
                                            
                                            // 평균 각도 계산
                                            if (angles.length > 0) {
                                                let sumAngle = angles.reduce((sum, a) => sum + a, 0);
                                                let avgAngle = sumAngle / angles.length;
                                                
                                                // 각도 보정 (180도 이상이면 음수로 변환)
                                                if (avgAngle > 90) avgAngle -= 180;
                                                else if (avgAngle < -90) avgAngle += 180;
                                                
                                                // 회전 행렬 계산
                                                let center = new cv.Point(processed.cols / 2, processed.rows / 2);
                                                let rotMat = cv.getRotationMatrix2D(center, avgAngle, 1);
                                                
                                                // 이미지 회전
                                                cv.warpAffine(processed, dst, rotMat, new cv.Size(processed.cols, processed.rows));
                                                dst.copyTo(processed);
                                                
                                                rotMat.delete();
                                            }
                                        }
                                        
                                        lines.delete();
                                    } catch (e) {
                                        console.error('기울기 보정 중 오류:', e);
                                        // 오류 발생 시 기존 이미지 유지
                                    }
                                }
                                
                                // 11. 결과 캔버스에 그리기
                                cv.imshow(canvas, processed);
                                
                                // 12. 이미지 URL 생성
                                const finalImageUrl = canvas.toDataURL('image/png', parseFloat(appSettings.imageQuality || 0.8));
                                
                                // 13. 메모리 정리 및 결과 반환
                                resolve(finalImageUrl);
                                
                            } finally {
                                // 14. 메모리 정리
                                src.delete();
                                dst.delete();
                                gray.delete();
                                blur.delete();
                                edges.delete();
                                processed.delete();
                            }
                            
                        } catch (error) {
                            console.error('OpenCV 처리 오류:', error);
                            // 오류 발생 시 원본 이미지 반환
                            resolve(imageUrl);
                        }
                    };
                    
                    img.onerror = function(error) {
                        console.error('이미지 로딩 오류:', error);
                        reject(new Error('이미지 로딩에 실패했습니다.'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('이미지 처리 초기화 오류:', error);
                    reject(error);
                }
            });
        }
        
        // 이미지 전처리 초기화
        function resetPreprocessing() {
            if (originalImageData) {
                capturedImage.src = originalImageData;
                showStatus('원본 이미지로 복원되었습니다.', 'success');
            }
        }
        
        // 미리보기 추가 함수
        function addPreview(label, imageUrl) {
            // 미리보기 컨테이너가 비어있으면 원본 이미지 추가
            if (previewContainer.children.length === 0 && originalImageData) {
                const originalPreview = document.createElement('div');
                originalPreview.className = 'preview-item';
                originalPreview.innerHTML = `
                    <img src="${originalImageData}" alt="원본 이미지">
                    <p>원본</p>
                `;
                previewContainer.appendChild(originalPreview);
                
                // 원본 이미지 클릭 이벤트
                originalPreview.addEventListener('click', () => {
                    capturedImage.src = originalImageData;
                });
            }
            
            // 새 미리보기 추가
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.innerHTML = `
                <img src="${imageUrl}" alt="${label} 이미지">
                <p>${label}</p>
            `;
            
            // 미리보기 클릭 이벤트
            previewItem.addEventListener('click', () => {
                capturedImage.src = imageUrl;
            });
            
            // 컨테이너에 추가
            previewContainer.appendChild(previewItem);
            previewContainer.style.display = 'flex';
        }
        
        // 명함 촬영 기능 수정 (플래시 효과 추가)
        captureBtn.addEventListener('click', async () => {
            try {
                // 플래시 효과 표시
                const flashEffect = document.getElementById('flashEffect');
                flashEffect.style.opacity = '1';
                
                setTimeout(() => {
                    flashEffect.style.opacity = '0';
                }, 200);
                
                // 캔버스 설정
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                
                // 비디오 프레임 캡처
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // 명함 감지 데이터가 있는 경우 활용
                if (lastDetectionResult && lastDetectionResult.success && lastDetectionResult.corners) {
                    // 감지된 명함 기반으로 고품질 처리
                    try {
                        // 투시 변환 적용
                        const transformedImage = await perspectiveTransformCard(
                            canvas.toDataURL('image/png', 1.0), // 원본 품질로 변환
                            lastDetectionResult.corners
                        );
                        
                        // 변환된 이미지 표시
                        capturedImage.src = transformedImage;
                        capturedImage.style.display = 'block';
                        
                        // 원본 이미지 저장
                        originalImageData = transformedImage;
                        
                        // 미리보기 추가
                        addPreview('자동 교정', transformedImage);
                        
                    } catch (transformError) {
                        console.error('명함 변환 오류:', transformError);
                        
                        // 변환 오류 시 기본 캡처 사용
                        capturedImage.src = canvas.toDataURL('image/png', parseFloat(appSettings.imageQuality || 0.95));
                        capturedImage.style.display = 'block';
                        
                        // 원본 이미지 저장
                        originalImageData = capturedImage.src;
                    }
                } else {
                    // 기본 캡처
                    capturedImage.src = canvas.toDataURL('image/png', parseFloat(appSettings.imageQuality || 0.95));
                    capturedImage.style.display = 'block';
                    
                    // 원본 이미지 저장
                    originalImageData = capturedImage.src;
                }
                
                // 버튼 상태 변경
                captureBtn.style.display = 'none';
                retakeBtn.style.display = 'inline-block';
                analyzeBtn.style.display = 'inline-block';
                improveImageBtn.style.display = 'inline-block';
                video.style.display = 'none';
                rotateButtons.style.display = 'flex';
                
                // 고급 모드면 고급 옵션 버튼 표시
                if (isAdvancedMode) {
                    advancedBtn.style.display = 'inline-block';
                }
                
                // 실시간 명함 감지 중지
                stopRealTimeCardDetection();
                
                // 회전 각도 초기화
                currentRotation = 0;
                
                showStatus('명함 촬영 완료! 이미지를 개선하거나 바로 분석할 수 있습니다.', 'success');
                
                // 처리 단계 표시
                stepsIndicator.style.display = 'flex';
                updateProcessingStep('preprocess');
                
                // 미리보기 초기화
                previewContainer.innerHTML = '';
                previewContainer.style.display = 'none';
                
                // 자동 이미지 개선 적용 (설정에 따라)
                if (appSettings.autoPreprocess) {
                    setTimeout(() => {
                        if (improveImageBtn.disabled === false) {
                            improveImageBtn.click();
                        }
                    }, 300);
                }
                
            } catch (error) {
                console.error('촬영 오류:', error);
                showStatus('촬영 중 오류가 발생했습니다. 다시 시도해주세요.', 'error');
            }
        });
        
        // 이미지 회전 함수
        function rotateImage(degrees) {
            try {
                // 현재 회전 각도 업데이트
                currentRotation = (currentRotation + degrees) % 360;
                if (currentRotation < 0) currentRotation += 360;
                
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 회전에 따라 캔버스 크기 조정
                    if (currentRotation === 90 || currentRotation === 270) {
                        canvas.width = img.height;
                        canvas.height = img.width;
                    } else {
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    
                    // 캔버스 중앙으로 이동하고 회전
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(currentRotation * Math.PI / 180);
                    
                    // 이미지 그리기 (중앙 기준으로)
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    
                    // 회전된 이미지 표시
                    capturedImage.src = canvas.toDataURL('image/png', parseFloat(appSettings.imageQuality || 0.8));
                };
                img.src = originalImageData || capturedImage.src;
                
            } catch (error) {
                console.error('이미지 회전 오류:', error);
                showStatus('이미지 회전 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // 이미지 회전 버튼 클릭 이벤트
        rotateLeftBtn.addEventListener('click', () => {
            rotateImage(-90);
        });
        
        rotateRightBtn.addEventListener('click', () => {
            rotateImage(90);
        });
        
        // 이미지 개선 버튼 이벤트
        improveImageBtn.addEventListener('click', async () => {
            try {
                improveImageBtn.disabled = true;
                improveImageBtn.textContent = '이미지 개선 중...';
                
                // 원본 이미지가 있는지 확인
                if (!capturedImage.src || !capturedImage.complete || capturedImage.naturalWidth === 0) {
                    throw new Error('유효한 이미지가 없습니다.');
                }
                
                // 원본 이미지 백업
                const originalSrc = capturedImage.src;
                
                showStatus('은행급 OCR을 위한 이미지 최적화 중...', 'info');
                
                // 은행급 OCR 최적화 이미지 처리
                const enhancedImage = await enhanceBusinessCardImageBankLevel(originalSrc, {
                    binarize: false,          // 기본값으로 이진화 비활성화 (텍스트 인식 정확도 향상)
                    adaptiveThreshold: false, // 기본값으로 적응형 이진화 비활성화
                    clahe: true,              // 대비 제한 적응형 히스토그램 평활화 활성화
                    sharpen: true,            // 선명도 향상 활성화
                    denoise: true             // 노이즈 제거 활성화
                });
                
                if (enhancedImage !== originalSrc) {
                    capturedImage.src = enhancedImage;
                    capturedImage.style.display = 'block';
                }
                
                improveImageBtn.textContent = '이미지 개선 완료';
                showStatus('은행급 OCR 최적화 완료!', 'success');
                
                setTimeout(() => {
                    improveImageBtn.textContent = '다시 개선';
                    improveImageBtn.disabled = false;
                }, 1500);
                
            } catch (error) {
                console.error('이미지 개선 오류:', error);
                improveImageBtn.textContent = '이미지 개선';
                improveImageBtn.disabled = false;
                showStatus(`이미지 개선 오류: ${error.message}`, 'error');
            }
        });
        
        // 고급 옵션 버튼 이벤트
        advancedBtn.addEventListener('click', () => {
            preprocessingOptions.style.display = preprocessingOptions.style.display === 'none' ? 'block' : 'none';
            advancedBtn.textContent = preprocessingOptions.style.display === 'none' ? '고급 옵션' : '옵션 닫기';
        });
        
        // 전처리 적용 버튼 이벤트
        applyPreprocessingBtn.addEventListener('click', () => {
            applyPreprocessing();
        });
        
        // 전처리 초기화 버튼 이벤트
        resetPreprocessingBtn.addEventListener('click', () => {
            resetPreprocessing();
        });
        
        // 품질 상세 정보 토글 이벤트 핸들러
        document.getElementById('detailsToggle').addEventListener('click', () => {
            const qualityDetails = document.getElementById('qualityDetails');
            qualityDetails.classList.toggle('active');
            
            const detailsToggle = document.getElementById('detailsToggle');
            detailsToggle.textContent = qualityDetails.classList.contains('active') ? 'x' : 'i';
        });
        
        // 자동 캡처 버튼 이벤트 핸들러
        document.getElementById('autoCaptureBtn').addEventListener('click', () => {
            captureBtn.click();
        });
        
        // OCR 실행 함수 수정 (고급 전처리 적용)
        async function performOCR(imageUrl, lang) {
            try {
                // 진행 상태 표시
                showStatus('OCR 인식 중...', 'info');
                progressBar.style.display = 'block';
                progressBarFill.style.width = '0%';
                
                // Tesseract 워커가 없으면 초기화
                if (!tesseractWorker) {
                    await initTesseract();
                }
                
                // 언어 변경이 필요한 경우
                try {
                    await tesseractWorker.loadLanguage(lang);
                    await tesseractWorker.initialize(lang);
                } catch (error) {
                    console.error('언어 변경 중 오류:', error);
                    // 실패 시 워커 재생성 시도
                    await tesseractWorker.terminate();
                    tesseractWorker = await Tesseract.createWorker();
                    await tesseractWorker.loadLanguage(lang);
                    await tesseractWorker.initialize(lang);
                }
                
                // 고급 OCR 설정
                const psm = appSettings.psm || '4';
                const oem = '1'; // LSTM only
                
                // 최고 품질 설정으로 OCR 실행
                const result = await tesseractWorker.recognize(imageUrl, {
                    tessedit_pageseg_mode: psm,
                    tessedit_ocr_engine_mode: oem,
                    tessjs_create_hocr: true,   // HOCR 출력 활성화
                    tessjs_create_tsv: true,    // TSV 출력 활성화
                    tessjs_create_box: true,    // Box 출력 활성화
                    tessedit_do_invert: false,  // 반전 비활성화 (이미 최적화된 이미지 가정)
                    preserve_interword_spaces: '1',
                    textord_tabfind_force_vertical_text: '0',
                    textord_tablefind_recognize_tables: '0'
                });
                
                // 결과 신뢰도 계산
                let confidence = 0;
                if (result.confidence) {
                    confidence = result.confidence;
                } else if (result.data && result.data.confidence) {
                    confidence = result.data.confidence;
                }
                
                // 원시 OCR 결과 표시 (고급 모드 또는 설정에 따라)
                if (isAdvancedMode || appSettings.showRawOcr) {
                    rawOcrResult.textContent = result.data.text;
                    rawOcrResult.style.display = 'block';
                }
                
                // 신뢰도 표시
                showConfidence(confidence);
                
                // 결과 반환
                return {
                    text: result.data.text,
                    confidence: confidence,
                    words: result.data.words || [],
                    hocr: result.data.hocr || '',
                    blocks: result.data.blocks || []
                };
                
            } catch (error) {
                console.error('OCR 처리 오류:', error);
                throw error;
            } finally {
                // 진행 상태 업데이트
                progressBarFill.style.width = '100%';
            }
        }
        
        // 신뢰도 표시 함수
        function showConfidence(confidence) {
            confidenceIndicator.style.display = 'flex';
            confidenceFill.style.width = `${confidence}%`;
            confidenceText.textContent = `${Math.round(confidence)}%`;
            
            // 신뢰도에 따른 색상 변경
            if (confidence >= 80) {
                confidenceFill.style.backgroundColor = '#28a745'; // 높음 (녹색)
            } else if (confidence >= 60) {
                confidenceFill.style.backgroundColor = '#ffc107'; // 중간 (노란색)
            } else {
                confidenceFill.style.backgroundColor = '#dc3545'; // 낮음 (빨간색)
            }
        }
        
        // 분석 버튼 클릭 이벤트 (Tesseract OCR 처리)
        analyzeBtn.addEventListener('click', async () => {
            // 진행 상태 표시
            showStatus('명함 분석 준비 중...', 'info');
            progressBar.style.display = 'block';
            progressBarFill.style.width = '0%';
            analyzeBtn.disabled = true;
            
            try {
                // 이미지 검증
                if (!capturedImage.src || !capturedImage.complete || capturedImage.naturalWidth === 0) {
                    throw new Error('유효한 이미지가 없습니다. 다시 촬영해주세요.');
                }
                
                // 언어 설정 가져오기
                const langConfig = languageMap[selectedLanguage];
                if (!langConfig) {
                    throw new Error('지원되지 않는 언어입니다.');
                }
                
                // 처리 단계 업데이트
                updateProcessingStep('ocr');
                
                // OCR 수행
                const ocrResult = await performOCR(capturedImage.src, langConfig.lang);
                
                // 인식 결과 검증
                if (!ocrResult.text || ocrResult.text.trim().length === 0) {
                    throw new Error('텍스트를 인식할 수 없습니다. 더 선명한 이미지로 다시 시도해주세요.');
                }
                
                // 신뢰도 표시
                showConfidence(ocrResult.confidence);
                
                // OCR 결과 저장
                lastOcrResult = ocrResult;
                
                // 처리 단계 업데이트
                updateProcessingStep('extract');
                
                // AI 분석 수행 (설정에 따라)
                let aiResults = null;
                if (appSettings.useAI) {
                    try {
                        aiResults = await analyzeWithAI(ocrResult.text);
                    } catch (aiError) {
                        console.error('AI 분석 오류:', aiError);
                        // AI 분석 실패해도 계속 진행
                    }
                }
                
                // 명함 정보 추출
                showStatus('명함 정보 분석 중...', 'info');
                
                const extractedInfo = await enhancedBusinessCardExtraction(
                    ocrResult, 
                    langConfig.keywords,
                    langConfig.lang,
                    aiResults
                );
                
                // 처리 단계 업데이트
                updateProcessingStep('review');
                
                // 추출된 정보를 폼에 채우기
                document.getElementById('name').value = extractedInfo.name || '';
                document.getElementById('position').value = extractedInfo.position || '';
                document.getElementById('company').value = extractedInfo.company || '';
                document.getElementById('department').value = extractedInfo.department || '';
document.getElementById('phone').value = extractedInfo.phone || extractedInfo.mobile || extractedInfo.tel || '';
                document.getElementById('email').value = extractedInfo.email || '';
                document.getElementById('website').value = extractedInfo.website || '';
                document.getElementById('address').value = extractedInfo.address || '';
                
                // 추가 정보가 있으면 메모 필드에 추가
                const additionalInfo = [];
                if (extractedInfo.fax) additionalInfo.push(`팩스: ${extractedInfo.fax}`);
                if (extractedInfo.tel && extractedInfo.tel !== extractedInfo.phone) {
                    additionalInfo.push(`전화: ${extractedInfo.tel}`);
                }
                if (extractedInfo.mobile && extractedInfo.mobile !== extractedInfo.phone) {
                    additionalInfo.push(`모바일: ${extractedInfo.mobile}`);
                }
                
                if (additionalInfo.length > 0) {
                    document.getElementById('notes').value = additionalInfo.join('\n');
                }
                
                // 폼 표시
                cardForm.style.display = 'block';
                
                // 진행 상태 업데이트
                let analysisType = appSettings.useAI ? "AI 기반" : "텍스트 기반";
                showStatus(`명함 분석 완료! (${analysisType} 분석, 신뢰도: ${Math.round(ocrResult.confidence || 0)}%)`, 'success');
                progressBarFill.style.width = '100%';
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    analyzeBtn.disabled = false;
                }, 1500);
                
            } catch (error) {
                console.error('명함 분석 오류:', error);
                
                // 오류 메시지 표시
                showStatus(`오류: ${error.message || '명함 분석 중 문제가 발생했습니다.'}`, 'error');
                
                // 제한된 정보로라도 폼 표시
                try {
                    // 메타 정보 추출 시도 (이메일, 전화번호만)
                    const metaInfo = {
                        name: '',
                        position: '',
                        company: '',
                        department: '',
                        phone: '',
                        email: '',
                        website: '',
                        address: ''
                    };
                    
                    if (lastOcrResult && lastOcrResult.text) {
                        // 이메일 추출
                        const emailMatches = lastOcrResult.text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g);
                        if (emailMatches && emailMatches.length > 0) {
                            metaInfo.email = emailMatches[0];
                        }
                        
                        // 전화번호 추출
                        const phoneMatches = lastOcrResult.text.match(/(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{3,4}/g);
                        if (phoneMatches && phoneMatches.length > 0) {
                            metaInfo.phone = phoneMatches[0];
                        }
                        
                        // 시간 패턴 관련 로직 (예시 명함에서 중요한 패턴)
                        const lines = lastOcrResult.text.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && line.length > 1);
                        
                        const timePattern = /[-=]{2}\s*[Ilm][mMnN]\s*\d{2}\s*\d{2}\s*[-=]{2}/;
                        
                        for (let i = 0; i < lines.length - 1; i++) {
                            if (timePattern.test(lines[i]) && i + 1 < lines.length) {
                                metaInfo.name = lines[i + 1]; // 시간 패턴 다음 줄이 이름
                                if (i + 2 < lines.length) {
                                    // 그 다음 줄은 보통 직책
                                    metaInfo.position = lines[i + 2];
                                }
                                if (i + 3 < lines.length) {
                                    // 그 다음 줄은 보통 회사
                                    metaInfo.company = lines[i + 3];
                                }
                                break;
                            }
                        }
                        
                        // 이름을 못 찾았다면 첫 번째 줄 확인
                        if (!metaInfo.name && lines.length > 0) {
                            // 첫 줄이 전체 대문자면 회사명으로 가정
                            if (/^[A-Z\s]+$/.test(lines[0])) {
                                metaInfo.company = lines[0];
                                if (lines.length > 1) {
                                    metaInfo.name = lines[1];
                                }
                            } else {
                                metaInfo.name = lines[0];
                            }
                        }
                    }
                    
                    // 폼에 기본 정보 채우기
                    document.getElementById('name').value = metaInfo.name;
                    document.getElementById('position').value = metaInfo.position;
                    document.getElementById('company').value = metaInfo.company;
                    document.getElementById('department').value = metaInfo.department;
                    document.getElementById('phone').value = metaInfo.phone;
                    document.getElementById('email').value = metaInfo.email;
                    document.getElementById('website').value = metaInfo.website;
                    document.getElementById('address').value = metaInfo.address;
                    
                    // 폼 표시
                    cardForm.style.display = 'block';
                    
                } catch (fallbackError) {
                    console.error('기본 정보 추출 실패:', fallbackError);
                    // 빈 폼 표시
                    cardForm.style.display = 'block';
                }
                
                // 버튼 상태 복원
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    analyzeBtn.disabled = false;
                }, 3000);
            }
        });
        
        // AI 기반 명함 정보 분석 함수
        async function analyzeWithAI(text) {
            if (!appSettings.useAI) return null;
            
            try {
                // AI 모델 확인
                const model = await loadUSEModel();
                if (!model) return null;
                
                showStatus('AI 분석 진행 중...', 'info');
                
                // 카테고리 예제 정의
                const categoryExamples = {
                    "이름": "홍길동 John Smith 김철수 Zhang Wei Tanaka Yuki Roy Young",
                    "회사": "주식회사 (주) 기업 그룹 연구소 학교 대학교 Corporation Company Ltd Inc Technology Co",
                    "직책": "대표 사장 이사 부장 과장 대리 연구원 Manager Director CEO CTO CFO President Executive",
                    "이메일": "example@example.com contact@company.com info@business.co.kr",
                    "전화번호": "010-1234-5678 02-123-4567 +82-10-1234-5678 (02)123-4567",
                    "웹사이트": "www.example.com https://company.co.kr http://business.net",
                    "주소": "서울시 강남구 테헤란로 123 New York, NY 10001 경기도 성남시 분당구"
                };
                
                // 결과 저장 객체
                const aiResults = [];
                
                // 텍스트 줄 분석
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                
                // 특별한 패턴 검색 (시간/날짜 패턴 및 특수 패턴)
                const timePattern = /[-=]{2}\s*[Ilm][mMnN]\s*\d{2}\s*\d{2}\s*[-=]{2}/;
                let timePatternFound = false;
                let nameAfterTimePattern = null;
                
                for (let i = 0; i < lines.length - 1; i++) {
                    if (timePattern.test(lines[i])) {
                        timePatternFound = true;
                        nameAfterTimePattern = lines[i + 1];
                        // 이미 이 패턴은 "이름" 카테고리로 관련성이 매우 높음
                        aiResults.push({
                            text: nameAfterTimePattern,
                            category: "이름",
                            similarity: 0.95
                        });
                        break;
                    }
                }
                
                // A HOLTOR 같은 상단에 있는 회사명 패턴 인식
                if (lines.length > 0 && /^[A-Z\s]+$/.test(lines[0])) {
                    aiResults.push({
                        text: lines[0],
                        category: "회사",
                        similarity: 0.9
                    });
                }
                
                // 각 줄에 대해 AI 분석 (시간 패턴에서 찾은 것은 제외)
                const linesToAnalyze = timePatternFound 
                    ? lines.filter(line => line !== nameAfterTimePattern)
                    : lines;
                
                // 분석할 줄 제한 (성능 최적화)
                const maxLinesToAnalyze = Math.min(10, linesToAnalyze.length);
                
                for (let i = 0; i < maxLinesToAnalyze; i++) {
                    const line = linesToAnalyze[i];
                    
                    // 분석에 적합한 줄인지 확인
                    if (line.length < 2 || line.length > 50) continue;
                    if (aiResults.some(r => r.text === line)) continue; // 이미 분석한 줄은 건너뛰기
                    
                    try {
                        // 각 텍스트 줄을 카테고리와 비교
                        const result = await findMostSimilarCategory(line, categoryExamples);
                        
                        if (result && result.category && result.similarity > 0.35) {
                            aiResults.push({
                                text: line,
                                category: result.category,
                                similarity: result.similarity
                            });
                        }
                    } catch (e) {
                        console.warn('줄 분석 오류:', line, e);
                    }
                }
                
                // 이메일과 URL 추출 (정규식 패턴 - 높은 정확도)
                const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                const emailMatches = text.match(emailRegex);
                
                if (emailMatches && emailMatches.length > 0) {
                    // 아직 결과에 없으면 추가
                    if (!aiResults.some(r => r.text.includes(emailMatches[0]))) {
                        aiResults.push({
                            text: emailMatches[0],
                            category: "이메일",
                            similarity: 0.98
                        });
                    }
                }
                
                const urlRegex = /(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+(?:\.[a-zA-Z]{2,})/g;
                const urlMatches = text.match(urlRegex);
                
                if (urlMatches && urlMatches.length > 0) {
                    // 이메일이 아니고 아직 결과에 없는 URL만 추가
                    const validUrls = urlMatches.filter(url => 
                        !url.includes('@') && 
                        !aiResults.some(r => r.text.includes(url))
                    );
                    
                    if (validUrls.length > 0) {
                        aiResults.push({
                            text: validUrls[0],
                            category: "웹사이트",
                            similarity: 0.95
                        });
                    }
                }
                
                // 전화번호 추출 (정규식 패턴)
                const phoneRegex = /(?:(?:\+|00)?82|0)?[ -]?(?:(?:(?:1[0-9]|[2-6][1-3]|70)[ -]?[0-9]{3,4})|(?:50[1-9])[ -]?[0-9]{2,3})[ -]?[0-9]{4}$|(?:\+?1[-\s\.]?)?\(?([0-9]{3})\)?[-\s\.]?([0-9]{3})[-\s\.]?([0-9]{4})|(?:(?:\+?81)|0)[-\s]?(?:[1-9]0(?:[1-9]|0)|\d{2}|\d{1})[-\s]?\d{4}[-\s]?\d{4}|(?:\+?86)?[-\s]?(?:(?:1[3-9][0-9]))[-\s]?[0-9]{4}[-\s]?[0-9]{4}|(?:\d{3,4})[-\s]?(?:\d{7,8})/g;
                const phoneMatches = text.match(phoneRegex);
                
                if (phoneMatches && phoneMatches.length > 0) {
                    // 아직 결과에 없는 전화번호만 추가
                    if (!aiResults.some(r => r.text.includes(phoneMatches[0]))) {
                        aiResults.push({
                            text: phoneMatches[0],
                            category: "전화번호",
                            similarity: 0.9
                        });
                    }
                }
                
                // 카테고리별로 정렬하고 각 카테고리에서 가장 높은 신뢰도를 가진 것만 선택
                const categorizedResults = {};
                
                for (const result of aiResults) {
                    if (!categorizedResults[result.category] || 
                        categorizedResults[result.category].similarity < result.similarity) {
                        categorizedResults[result.category] = result;
                    }
                }
                
                // 결과를 배열로 변환
                const finalResults = Object.values(categorizedResults);
                
                // 만약 고급 모드이면 UI에 결과 표시
                if (isAdvancedMode) {
                    displayAIResults(finalResults);
                }
                
                return finalResults;
            } catch (error) {
                console.error('AI 분석 오류:', error);
                return null;
            }
        }
        
        // AI 결과 표시 함수
        function displayAIResults(results) {
            if (!results || results.length === 0) {
                aiResults.style.display = 'none';
                return;
            }
            
            // 결과 컨테이너 초기화
            aiResultsList.innerHTML = '';
            
            // 결과 표시
            for (const result of results) {
                const confidence = Math.round(result.similarity * 100);
                const item = document.createElement('div');
                item.className = 'ai-item';
                item.innerHTML = `
                    <div class="ai-category">${result.category}:</div>
                    <div class="ai-text">${result.text}</div>
                    <div class="ai-confidence">${confidence}%</div>
                `;
                aiResultsList.appendChild(item);
            }
            
            // 결과 컨테이너 표시
            aiResults.style.display = 'block';
        }
        
        // 고급 명함 정보 추출 함수 (AI 분석 결과 활용)
        async function enhancedBusinessCardExtraction(ocrResult, keywords, langCode, aiAnalysisResults = null) {
            try {
                // OCR 결과 텍스트
                const text = ocrResult.text;
                const words = ocrResult.words || [];
                
                // 기본 정보 객체
                const info = {
                    name: '',
                    position: '',
                    company: '',
                    department: '',
                    phone: '',
                    mobile: '',
                    tel: '',
                    fax: '',
                    email: '',
                    website: '',
                    address: ''
                };
                
                // AI 분석 결과가 있으면 먼저 활용
                if (aiAnalysisResults && aiAnalysisResults.length > 0) {
                    for (const result of aiAnalysisResults) {
                        if (result.category === "이름" && result.similarity > 0.4) {
                            info.name = result.text;
                        } else if (result.category === "회사" && result.similarity > 0.4) {
                            info.company = result.text;
                        } else if (result.category === "직책" && result.similarity > 0.4) {
                            info.position = result.text;
                        } else if (result.category === "전화번호" && result.similarity > 0.4) {
                            info.phone = result.text;
                        } else if (result.category === "이메일" && result.similarity > 0.4) {
                            info.email = result.text;
                        } else if (result.category === "웹사이트" && result.similarity > 0.4) {
                            info.website = result.text;
                        } else if (result.category === "주소" && result.similarity > 0.4) {
                            info.address = result.text;
                        }
                    }
                }
                
                // 인식된 텍스트를 줄별로 분할 및 정제
                const rawLines = text.split('\n');
                
                // 줄 정제: 빈 줄 제거, 공백 제거, 특수문자 처리
                let lines = rawLines
                    .map(line => line.trim())
                    .filter(line => line && line.length > 1);
                
                // 1. 이메일 추출 (정규식 패턴 - 가장 신뢰성 높음)
                if (!info.email) {
                    let emailMatches = text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g);
                    if (emailMatches && emailMatches.length > 0) {
                        info.email = emailMatches[0];
                    }
                }
                
                // 2. 웹사이트 URL 추출 (정규식 패턴)
                if (!info.website) {
                    let urlMatches = text.match(/(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+(?:\.[a-zA-Z]{2,})(?:\/\S*)?/g);
                    if (urlMatches && urlMatches.length > 0) {
                        // 이메일이 아닌 URL만 필터링
                        const validUrls = urlMatches.filter(url => !url.includes('@'));
                        if (validUrls.length > 0) {
                            info.website = validUrls[0];
                        }
                    }
                }
                
                // 3. 전화번호 추출 (언어별 패턴)
                if (!info.phone) {
                    const phonePatterns = [
                        // 모바일 패턴
                        {
                            regex: new RegExp(`(?:(?:휴대(?:폰|전화)|핸드폰|Mobile|모바일|携帯|手机)[\\s:).-]*)?(?:\\+?\\d{1,4}[\\s-]?)?(?:\\(?\\d{2,4}\\)?[\\s-]?)?\\d{3,4}[\\s-]?\\d{3,4}`, 'gi'),
                            type: 'mobile'
                        },
                        // 일반 전화 패턴
                        {
                            regex: new RegExp(`(?:(?:전화|사무실|Tel|TEL|电话|電話|T|P|Ph)[\\s:).-]*)?(?:\\+?\\d{1,4}[\\s-]?)?(?:\\(?\\d{2,4}\\)?[\\s-]?)?\\d{3,4}[\\s-]?\\d{3,4}`, 'gi'),
                            type: 'tel'
                        },
                        // 팩스 패턴
                        {
                            regex: new RegExp(`(?:(?:팩스|Fax|FAX|传真|F)[\\s:).-]*)?(?:\\+?\\d{1,4}[\\s-]?)?(?:\\(?\\d{2,4}\\)?[\\s-]?)?\\d{3,4}[\\s-]?\\d{3,4}`, 'gi'),
                            type: 'fax'
                        },
                        // 일반 숫자 패턴
                        {
                            regex: /(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{3,4}(?:[\s-]?\d{3,4})?/g,
                            type: 'phone'
                        }
                    ];
                    
                    // 매칭된 전화번호 저장
                    const matchedNumbers = new Set();
                    
                    // 각 패턴별로 검색
                    for (const pattern of phonePatterns) {
                        const matches = text.match(pattern.regex);
                        if (matches && matches.length > 0) {
                            for (const match of matches) {
                                // 숫자만 추출해서 중복 체크 (다양한 포맷으로 동일 번호가 추출될 수 있음)
                                const digitsOnly = match.replace(/\D/g, '');
                                
                                // 너무 짧거나 긴 번호는 건너뛰기
                                if (digitsOnly.length < 7 || digitsOnly.length > 15) continue;
                                
                                // 이미 추출한 번호면 건너뛰기
                                if (matchedNumbers.has(digitsOnly)) continue;
                                
                                // 전화번호 형식화
                                let formattedNumber = match.trim();
                                
                                // 전화번호 유형 저장
                                if (pattern.type === 'mobile' && !info.mobile) {
                                    info.mobile = formattedNumber;
                                } else if (pattern.type === 'tel' && !info.tel) {
                                    info.tel = formattedNumber;
                                } else if (pattern.type === 'fax' && !info.fax) {
                                    info.fax = formattedNumber;
                                } else if (pattern.type === 'phone' && !info.phone) {
                                    info.phone = formattedNumber;
                                }
                                
                                // 매칭된 번호 저장
                                matchedNumbers.add(digitsOnly);
                            }
                        }
                    }
                    
                    // 대표 전화번호 설정 (모바일 > 일반전화 > 팩스 순)
                    if (!info.phone) {
                        info.phone = info.mobile || info.tel || '';
                    }
                }
                
                // 4. 이름 추출 (AI 결과가 없는 경우)
                if (!info.name) {
                    // 특별한 시간/날짜 형식 패턴 확인 (예: "-- lm 00 00 ==")
                    const timePattern = /[-=]{2}\s*[Ilm][mMnN]\s*\d{2}\s*\d{2}\s*[-=]{2}/;
                    let nameAfterTimePattern = null;
                    
                    // 시간 패턴 다음 줄을 이름으로 간주 (많은 명함이 이런 형식 사용)
                    for (let i = 0; i < lines.length - 1; i++) {
                        if (timePattern.test(lines[i]) && i + 1 < lines.length) {
                            nameAfterTimePattern = lines[i + 1];
                            break;
                        }
                    }
                    
                    if (nameAfterTimePattern) {
                        info.name = nameAfterTimePattern;
                    } else {
                        // 일반적인 이름 추출
                        // 짧고 특수 문자가 없는 첫 번째/두 번째 줄을 이름으로 추정
                        const nameLines = lines.filter(line => 
                            line.length < 25 && 
                            line.length > 1 &&
                            !line.includes('@') && 
                            !line.includes('http') &&
                            !/\d{4,}/.test(line) && // 긴 숫자가 없는 줄
                            !/^[\d\s\-+.()]+$/.test(line) // 전화번호만 있는 줄이 아닌 것
                        );
                        
                        if (nameLines.length > 0) {
                            // 언어별 특성에 맞는 처리
                            let nameFirst = true;
                            if (langCode.includes('kor') || langCode.includes('jpn') || langCode.includes('chi_sim')) {
                                nameFirst = true; // 동아시아 언어는 이름이 먼저 나옴
                            } else {
                                nameFirst = false; // 서양 언어는 회사/직책이 먼저 나오는 경우가 많음
                            }
                            
                            // 위치 기반 이름 추출
                            if (nameFirst && nameLines.length > 0) {
                                // 동아시아 언어: 첫 번째 짧은 줄을 이름으로
                                info.name = nameLines[0];
                            } else if (nameLines.length > 1) {
                                // 서양 언어: 두 번째 또는 세 번째 짧은 줄을 이름으로
                                info.name = nameLines[1] || nameLines[0];
                            } else {
                                info.name = nameLines[0];
                            }
                        }
                    }
                    
                    // 이름 정제
                    if (info.name) {
                        info.name = info.name.replace(/^\s*[.•*-]\s*/, ''); // 줄 앞의 기호 제거
                    }
                }
                
                // 5. 회사명 추출 (AI 결과가 없는 경우)
                if (!info.company) {
                    // 첫 줄이 대문자로만 된 경우 회사로 간주 (예: "A HOLTOR")
                    if (lines.length > 0 && /^[A-Z\s]+$/.test(lines[0])) {
                        info.company = lines[0];
                    } else {
                        // 키워드 기반 회사명 탐색
                        for (const line of lines) {
                            if (keywords.company.some(keyword => line.includes(keyword))) {
                                info.company = line;
                                break;
                            }
                        }
                        
                        // 회사명이 없으면 위치 기반으로 추정
                        if (!info.company && lines.length > 1) {
                            const nameIndex = info.name ? lines.indexOf(info.name) : -1;
                            
                            if (nameIndex === 0 && lines.length > 1) {
                                // 이름이 첫 줄이면 두 번째 줄이 회사일 가능성 높음
                                info.company = lines[1];
                            } else if (nameIndex === -1 && lines.length > 0) {
                                // 이름을 찾지 못했으면 첫 줄이 회사일 가능성
                                info.company = lines[0];
                            }
                        }
                    }
                }
                
                // 6. 직책 추출 (AI 결과가 없는 경우)
                if (!info.position) {
                    // 키워드 기반 직책 탐색
                    for (const line of lines) {
                        if (keywords.position.some(keyword => line.includes(keyword))) {
                            info.position = line;
                            break;
                        }
                    }
                    
                    // 직책이 없으면 위치 기반으로 추정
                    if (!info.position && info.name && info.company) {
                        const nameIndex = lines.indexOf(info.name);
                        const companyIndex = lines.indexOf(info.company);
                        
                        if (nameIndex !== -1 && companyIndex !== -1) {
                            // 이름과 회사 사이에 있는 줄을 직책으로 간주
                            const indices = [nameIndex, companyIndex].sort((a, b) => a - b);
                            if (indices[1] - indices[0] === 2) {
                                const middleIndex = indices[0] + 1;
                                info.position = lines[middleIndex];
                            }
                        }
                    }
                }
                
                // 7. 부서 추출
                if (!info.department) {
                    // 키워드 기반 부서 탐색
                    for (const line of lines) {
                        if (keywords.department.some(keyword => line.includes(keyword))) {
                            info.department = line;
                            break;
                        }
                    }
                }
                
                // 8. 주소 추출
                if (!info.address) {
                    // 가장 긴 줄을 주소로 간주 (전화번호, 이메일, URL 아닌 것들 중에서)
                    const addressCandidates = lines.filter(line => 
                        line.length > 20 && 
                        !line.includes('@') && 
                        !line.includes('www.') && 
                        !line.includes('http') &&
                        !/^[\d\s\-+.()]+$/.test(line) // 전화번호만 있는 줄이 아닌 것
                    );
                    
                    if (addressCandidates.length > 0) {
                        // 가장 긴 줄을 주소로 설정
                        info.address = addressCandidates.reduce((a, b) => a.length >= b.length ? a : b);
                    }
                }
                
                // 9. 정보 정제
                if (info.name) info.name = info.name.trim();
                if (info.company) info.company = info.company.trim();
                if (info.position) info.position = info.position.trim();
                if (info.department) info.department = info.department.trim();
                if (info.phone) info.phone = info.phone.trim();
                if (info.email) info.email = info.email.trim();
                if (info.website) info.website = info.website.trim();
                if (info.address) info.address = info.address.trim();
                
                return info;
                
            } catch (error) {
                console.error('명함 정보 추출 오류:', error);
                
                // 오류 발생 시 기본 정보 추출 시도
                const basicInfo = {
                    name: '',
                    position: '',
                    company: '',
                    department: '',
                    phone: '',
                    email: '',
                    website: '',
                    address: ''
                };
                
                try {
                    // 이메일 추출 시도
                    const emailMatches = ocrResult.text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g);
                    if (emailMatches && emailMatches.length > 0) {
                        basicInfo.email = emailMatches[0];
                    }
                    
                    // 전화번호 추출 시도
                    const phoneMatches = ocrResult.text.match(/(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{3,4}/g);
                    if (phoneMatches && phoneMatches.length > 0) {
                        basicInfo.phone = phoneMatches[0];
                    }
                    
                    // 줄 분할
                    const lines = ocrResult.text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line && line.length > 1);
                    
                    // 시간 패턴 검색 (-- lm 00 00 == 다음에 오는 줄이 이름일 가능성이 높음)
                    const timePattern = /[-=]{2}\s*[Ilm][mMnN]\s*\d{2}\s*\d{2}\s*[-=]{2}/;
                    let nameFound = false;
                    
                    for (let i = 0; i < lines.length - 1; i++) {
                        if (timePattern.test(lines[i])) {
                            basicInfo.name = lines[i + 1];
                            nameFound = true;
                            break;
                        }
                    }
                    
                    // 시간 패턴에서 이름을 찾지 못했으면 첫 번째 줄을 이름으로
                    if (!nameFound && lines.length > 0) {
                        // 첫 줄이 대문자로만 된 경우는 회사로 간주
                        if (/^[A-Z\s]+$/.test(lines[0])) {
                            basicInfo.company = lines[0];
                            if (lines.length > 1) {
                                basicInfo.name = lines[1];
                            }
                        } else {
                            basicInfo.name = lines[0];
                        }
                    }
                    
                    // 회사명 추출 시도
                    if (!basicInfo.company && lines.length > 1) {
                        for (let i = 0; i < Math.min(3, lines.length); i++) {
                            const line = lines[i];
                            if (line !== basicInfo.name && 
                                (line.includes('주식회사') || line.includes('(주)') || 
                                 line.includes('Co.') || line.includes('Ltd') || 
                                 line.includes('Inc') || line.includes('Corp'))) {
                                basicInfo.company = line;
                                break;
                            }
                        }
                        
                        // 키워드가 없으면 두 번째나 세 번째 줄을 회사로 추정
                        if (!basicInfo.company && lines.length > 1) {
                            const nameIndex = lines.indexOf(basicInfo.name);
                            if (nameIndex === 0 && lines.length > 1) {
                                basicInfo.company = lines[1];
                            } else if (nameIndex === 1 && lines.length > 2) {
                                basicInfo.company = lines[0] || lines[2];
                            }
                        }
                    }
                    
                } catch (e) {
                    console.error('기본 정보 추출 중 오류:', e);
                }
                
                return basicInfo;
            }
        }
        
        // 명함 저장
        saveBtn.addEventListener('click', () => {
            try {
                const newCard = {
                    id: Date.now().toString(), // 고유 ID 생성
                    name: document.getElementById('name').value,
                    position: document.getElementById('position').value,
                    company: document.getElementById('company').value,
                    department: document.getElementById('department').value,
                    phone: document.getElementById('phone').value,
                    email: document.getElementById('email').value,
                    website: document.getElementById('website').value,
                    address: document.getElementById('address').value,
                    notes: document.getElementById('notes').value,
                    registeredDate: new Date().toISOString()
                };
                
                // 필수 필드 검증
                if (!newCard.name.trim()) {
                    showStatus('이름은 필수 입력 항목입니다.', 'error');
                    return;
                }
                
                // 명함 데이터 배열에 추가
                businessCards.push(newCard);
                
                // 로컬 스토리지에 저장
                saveBusinessCards();
                
                // 폼 초기화
                resetForm();
                
                // 대시보드 탭으로 전환
                tabs[1].click();
                
                showStatus('명함이 성공적으로 저장되었습니다!', 'success');
            } catch (error) {
                console.error('명함 저장 오류:', error);
                showStatus('명함 저장 중 오류가 발생했습니다.', 'error');
            }
        });
        
        // 폼 초기화
        function resetForm() {
            document.getElementById('name').value = '';
            document.getElementById('position').value = '';
            document.getElementById('company').value = '';
            document.getElementById('department').value = '';
            document.getElementById('phone').value = '';
            document.getElementById('email').value = '';
            document.getElementById('website').value = '';
            document.getElementById('address').value = '';
            document.getElementById('notes').value = '';
            
            capturedImage.style.display = 'none';
            captureBtn.style.display = 'inline-block';
            retakeBtn.style.display = 'none';
            analyzeBtn.style.display = 'none';
            advancedBtn.style.display = 'none';
            improveImageBtn.style.display = 'none';
            cardForm.style.display = 'none';
            video.style.display = 'block';
            rotateButtons.style.display = 'none';
            confidenceIndicator.style.display = 'none';
            stepsIndicator.style.display = 'none';
            preprocessingOptions.style.display = 'none';
            previewContainer.style.display = 'none';
            rawOcrResult.style.display = 'none';
            aiResults.style.display = 'none';
            
            // 명함 인식 가이드 다시 표시
            document.getElementById('cardScanningGuide').style.display = 'block';
            
            // 실시간 명함 감지 재시작
            if (realTimeBoundaryDetection) {
                startRealTimeCardDetection();
            }
            
            analyzeBtn.disabled = false;
            improveImageBtn.disabled = false;
            improveImageBtn.textContent = '이미지 개선';
            statusMessage.style.display = 'none';
            
            // 원본 이미지 데이터 초기화
            originalImageData = null;
            
            // 회전 각도 초기화
            currentRotation = 0;
            
            // 처리 단계 초기화
            updateProcessingStep('capture');
        }
        
        // 명함 삭제
        function deleteBusinessCard(id) {
            if (confirm('이 명함을 삭제하시겠습니까?')) {
                businessCards = businessCards.filter(card => card.id !== id);
                saveBusinessCards();
                renderCardList(searchInput.value);
                showStatus('명함이 삭제되었습니다.', 'success');
            }
        }
        
        // 수정 모달 열기
        function openEditModal(id) {
            const card = businessCards.find(card => card.id === id);
            
            if (card) {
                currentEditId = id;
                
                document.getElementById('editName').value = card.name || '';
                document.getElementById('editPosition').value = card.position || '';
                document.getElementById('editCompany').value = card.company || '';
                document.getElementById('editDepartment').value = card.department || '';
                document.getElementById('editPhone').value = card.phone || '';
                document.getElementById('editEmail').value = card.email || '';
                document.getElementById('editWebsite').value = card.website || '';
                document.getElementById('editAddress').value = card.address || '';
                document.getElementById('editNotes').value = card.notes || '';
                
                editModal.style.display = 'block';
            }
        }
        
        // 명함 정보 업데이트
        updateBtn.addEventListener('click', () => {
            if (currentEditId) {
                // 필수 필드 검증
                const name = document.getElementById('editName').value.trim();
                if (!name) {
                    showStatus('이름은 필수 입력 항목입니다.', 'error');
                    return;
                }
                
                const index = businessCards.findIndex(card => card.id === currentEditId);
                
                if (index !== -1) {
                    businessCards[index] = {
                        ...businessCards[index],
                        name: name,
                        position: document.getElementById('editPosition').value,
                        company: document.getElementById('editCompany').value,
                        department: document.getElementById('editDepartment').value,
                        phone: document.getElementById('editPhone').value,
                        email: document.getElementById('editEmail').value,
                        website: document.getElementById('editWebsite').value,
                        address: document.getElementById('editAddress').value,
                        notes: document.getElementById('editNotes').value
                    };
                    
                    saveBusinessCards();
                    renderCardList(searchInput.value);
                    
                    editModal.style.display = 'none';
                    showStatus('명함 정보가 업데이트되었습니다.', 'success');
                }
            }
        });
        
        // 오류 저항성 높은 앱 설정
        function setupErrorResistantApp() {
            // 메모리 및 성능 최적화
            setupPerformanceOptimization();
            
            // 오류 처리를 위한 전역 핸들러 추가
            window.addEventListener('error', function(event) {
                console.error('전역 오류 발생:', event.error);
                // 치명적 오류 발생 시 사용자에게 알림
                showStatus(`오류가 발생했습니다: ${event.error?.message || '알 수 없는 오류'}. 필요한 경우 페이지를 새로고침하세요.`, 'error');
            });
            
            // 네트워크 상태 모니터링
            window.addEventListener('online', function() {
                showStatus('인터넷 연결이 복원되었습니다.', 'success');
            });
            
            window.addEventListener('offline', function() {
                showStatus('인터넷 연결이 끊겼습니다. 일부 기능이 제한될 수 있습니다.', 'error');
            });
            
            // 언로드 핸들러
            window.addEventListener('beforeunload', function() {
                // 카메라 스트림 정리
                if (video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                }
                
                // Tesseract 워커 종료
                if (tesseractWorker) {
                    tesseractWorker.terminate();
                }
            });
        }
        
        // 성능 최적화 설정
        function setupPerformanceOptimization() {
            // 1. 비활성 탭에서 카메라 중지
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && video.srcObject) {
                    // 페이지가 숨겨지면 카메라 중지
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    
                    // 사용자에게 알림
                    showStatus('페이지가 백그라운드로 이동하여 카메라가 중지되었습니다. 다시 접근하려면 새로고침하세요.', 'info');
                    accessCameraBtn.style.display = 'block';
                    accessCameraBtn.textContent = '카메라 다시 접근';
                    video.style.display = 'none';
                }
            });
            
            // 2. 디바운스 구현 (검색 필드)
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    renderCardList(e.target.value);
                }, 300); // 300ms 지연
            });
            
            // 3. 이미지 최적화
            const quality = parseFloat(appSettings.imageQuality || 0.8);
            const maxWidth = 1280; // 최대 이미지 너비 제한
            
            // 이미지 업로드 전 최적화 이벤트 추가
            fileInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    
                    // 이미지 파일만 처리
                    if (!file.type.startsWith('image/')) {
                        showStatus('이미지 파일만 업로드할 수 있습니다.', 'error');
                        fileInput.value = '';
                        return;
                    }
                    
                    // 파일 크기 확인 (5MB 초과 시 최적화)
                    if (file.size > 5 * 1024 * 1024) {
                        showStatus('큰 이미지 파일입니다. 최적화를 진행합니다...', 'info');
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                // 이미지 크기 제한 및 품질 조정
                                const canvas = document.createElement('canvas');
                                let width = img.width;
                                let height = img.height;
                                
                                // 너비 제한
                                if (width > maxWidth) {
                                    height = (maxWidth / width) * height;
                                    width = maxWidth;
                                }
                                
                                canvas.width = width;
                                canvas.height = height;
                                
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, width, height);
                                
                                // 최적화된 이미지 표시
                                capturedImage.src = canvas.toDataURL('image/jpeg', quality);
                                capturedImage.style.display = 'block';
                                
                                // 원본 이미지 저장
                                originalImageData = capturedImage.src;
                                
                                // UI 업데이트
                                video.style.display = 'none';
                                accessCameraBtn.style.display = 'none';
                                captureBtn.style.display = 'none';
                                retakeBtn.style.display = 'inline-block';
                                analyzeBtn.style.display = 'inline-block';
                                improveImageBtn.style.display = 'inline-block';
                                rotateButtons.style.display = 'flex';
                                
                                // 고급 모드면 고급 옵션 버튼 표시
                                if (isAdvancedMode) {
                                    advancedBtn.style.display = 'inline-block';
                                }
                                
                                // 회전 각도 초기화
                                currentRotation = 0;
                                
                                // 처리 단계 표시
                                stepsIndicator.style.display = 'flex';
                                updateProcessingStep('preprocess');
                                
                                showStatus('이미지가 최적화되어 업로드되었습니다.', 'success');
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                        
                        // 파일 입력 초기화 (중복 처리 방지)
                        fileInput.value = '';
                    }
                    // 이미 적정 크기면 그대로 처리
                }
            });
        }
        
        // 환영 가이드 표시 함수
        function showWelcomeGuide() {
            // 첫 방문인지 확인
            const hasVisitedBefore = localStorage.getItem('hasVisitedBefore');
            
            if (!hasVisitedBefore) {
                // 가이드 컨테이너 생성
                const guideContainer = document.createElement('div');
                guideContainer.className = 'camera-guide';
                guideContainer.innerHTML = `
                    <h3>고급 명함 인식 시스템 사용 가이드</h3>
                    <p>은행 수준의 OCR 기술로 더 정확한 명함 인식이 가능합니다.</p>
                    <ul>
                        <li>밝은 환경에서 명함을 화면 중앙에 위치시키세요.</li>
                        <li>화면에 표시된 가이드 프레임에 명함을 맞춰주세요.</li>
                        <li>흔들림 없이 촬영하고, 품질 지표가 녹색일 때 촬영하세요.</li>
                        <li>최적 상태가 감지되면 자동 촬영 버튼이 나타납니다.</li>
                    </ul>
                    <button id="closeGuideBtn" style="background-color: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; margin-top: 10px;">확인</button>
                `;
                
                // 카메라 컨텐츠 상단에 추가
                const cameraContent = document.getElementById('cameraContent');
                cameraContent.insertBefore(guideContainer, cameraContent.firstChild);
                
                // 가이드 닫기 버튼 이벤트
                document.getElementById('closeGuideBtn').addEventListener('click', () => {
                    guideContainer.style.display = 'none';
                    localStorage.setItem('hasVisitedBefore', 'true');
                });
            }
        }
        
        // 페이지 로드 시 설정 및 저장된 명함 불러오기
        document.addEventListener('DOMContentLoaded', () => {
            // 설정 로드
            loadSettings();
            
            // 카메라 접근 버튼 초기 표시
            accessCameraBtn.style.display = 'block';
            video.style.display = 'none';
            captureBtn.style.display = 'none';
            
            // 저장된 명함 불러오기
            loadBusinessCards();
            
            // MediaDevices API 지원 확인
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showStatus('이 브라우저는 카메라 접근을 지원하지 않습니다. 파일 업로드를 사용해주세요.', 'error');
                accessCameraBtn.disabled = true;
                accessCameraBtn.textContent = '카메라 지원되지 않음';
            }
            
            // OpenCV 상태 체크
            if (typeof cv !== 'undefined') {
                onOpenCvReady();
            } else {
                opencvStatus.innerHTML = '<div class="spinner"></div> OpenCV.js 로딩 중... 잠시 기다려주세요.';
            }
            
            // Tesseract 초기화
            initTesseract();
            
            // AI 모델 사전 로딩 (설정에 따라)
            if (appSettings.useAI) {
                setTimeout(() => {
                    loadUSEModel().catch(err => console.warn('AI 모델 사전 로딩 실패:', err));
                }, 3000); // 3초 후 모델 로딩 시작
            }
            
            // 품질 상세 정보 토글 이벤트 설정
            document.getElementById('detailsToggle').addEventListener('click', () => {
                const qualityDetails = document.getElementById('qualityDetails');
                qualityDetails.classList.toggle('active');
            });
            
            // 명함 감지 토글 추가
            addCardDetectionToggle();
            
            // 환영 가이드 표시
            showWelcomeGuide();
            
            // 오류 저항성 설정
            setupErrorResistantApp();
        });
        
        // 모달 닫기
        closeModal.addEventListener('click', () => {
            editModal.style.display = 'none';
        });
        
        // 모달 외부 클릭 시 닫기
        window.addEventListener('click', (e) => {
            if (e.target === editModal) {
                editModal.style.display = 'none';
            } else if (e.target === importModal) {
                importModal.style.display = 'none';
            }
        });
    </script>
</body>
</html>
