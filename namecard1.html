// 1. 고급 명함 인식 및 정보 추출 시스템

// 이미지 전처리 파이프라인 - 인식률 향상을 위한 단계별 처리
async function advancedPreprocessImage(imageUrl) {
    return new Promise((resolve, reject) => {
        try {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                try {
                    // 원본 캔버스 생성
                    const originalCanvas = document.createElement('canvas');
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    const originalCtx = originalCanvas.getContext('2d');
                    originalCtx.drawImage(img, 0, 0, img.width, img.height);
                    const originalData = originalCtx.getImageData(0, 0, img.width, img.height);
                    
                    // 처리용 캔버스 생성
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    
                    // 1. 크기 최적화 - OCR 엔진을 위한 이상적인 크기로 조정
                    let processedWidth = img.width;
                    let processedHeight = img.height;
                    
                    // OCR에 최적화된 크기는 2000-3000px 범위 (너무 작으면 텍스트 인식이 어렵고, 너무 크면 처리 속도가 느림)
                    const OPTIMAL_SIZE = 2500;
                    const MINIMUM_SIZE = 1000;
                    
                    let scale = 1;
                    if (Math.max(processedWidth, processedHeight) > OPTIMAL_SIZE) {
                        scale = OPTIMAL_SIZE / Math.max(processedWidth, processedHeight);
                        processedWidth *= scale;
                        processedHeight *= scale;
                    } else if (Math.max(processedWidth, processedHeight) < MINIMUM_SIZE) {
                        scale = MINIMUM_SIZE / Math.max(processedWidth, processedHeight);
                        processedWidth *= scale;
                        processedHeight *= scale;
                    }
                    
                    canvas.width = processedWidth;
                    canvas.height = processedHeight;
                    
                    // 2. 초기 이미지 그리기
                    ctx.drawImage(img, 0, 0, processedWidth, processedHeight);
                    
                    // 3. 이미지 데이터 가져오기
                    let imageData = ctx.getImageData(0, 0, processedWidth, processedHeight);
                    let data = imageData.data;
                    
                    // 4. 색상 히스토그램 분석 - 이미지 특성에 따른 동적 처리
                    let histogram = new Array(256).fill(0);
                    for (let i = 0; i < data.length; i += 4) {
                        const grayscale = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                        histogram[grayscale]++;
                    }
                    
                    // 5. Otsu 알고리즘을 사용한 적응형 임계값 찾기
                    const threshold = calculateOtsuThreshold(histogram, data.length / 4);
                    
                    // 6. 노이즈 감소 및 선명도 향상을 위한 가우시안 블러 적용
                    const blurRadius = 1; // 약한 블러 적용
                    applyGaussianBlur(data, processedWidth, processedHeight, blurRadius);
                    
                    // 7. 적응형 이진화 - 언어에 따라 다른 처리 적용
                    if (selectedLanguage.includes('chi_sim') || selectedLanguage.includes('jpn')) {
                        // 동아시아 언어는 더 미세한 문자 필획 보존이 중요
                        applySauvolaThresholding(data, processedWidth, processedHeight, 10, 0.3);
                    } else {
                        // 명함 배경과 텍스트 대비 향상
                        applyAdaptiveThresholding(data, processedWidth, processedHeight, threshold);
                    }
                    
                    // 8. 언어에 따른 세부 처리
                    switch(selectedLanguage) {
                        case 'kor':
                            // 한글은 모음과 자음의 연결 부분 강화
                            applyMorphologicalOperation(data, processedWidth, processedHeight, 'dilate', 1);
                            break;
                        case 'eng':
                            // 영어는 대비 증가
                            applyContrastEnhancement(data, processedWidth, processedHeight, 1.3);
                            break;
                        case 'jpn':
                        case 'chi_sim':
                            // 동아시아 문자는 노이즈 제거 강화
                            applyMorphologicalOperation(data, processedWidth, processedHeight, 'erode', 1);
                            applyMorphologicalOperation(data, processedWidth, processedHeight, 'dilate', 1);
                            break;
                        case 'multi':
                            // 일반적인 향상만 적용
                            applyContrastEnhancement(data, processedWidth, processedHeight, 1.2);
                            break;
                    }
                    
                    // 9. 엣지 강화 - 텍스트 윤곽 강조
                    applyUnsharpMasking(data, processedWidth, processedHeight, 0.8);
                    
                    // 10. 이미지 평탄화 - 명함 정면이 기울어진 경우 보정
                    // (실제 구현은 복잡하므로 프로토타입에서는 생략)
                    
                    // 11. 처리된 데이터를 캔버스에 적용
                    ctx.putImageData(imageData, 0, 0);
                    
                    // 12. 최종 이미지 생성
                    try {
                        const enhancedImage = canvas.toDataURL('image/png');
                        
                        // 처리 결과 반환 - 디버깅을 위해 원본 및 처리 이미지 모두 포함
                        resolve({
                            original: originalCanvas.toDataURL('image/png'),
                            processed: enhancedImage,
                            width: processedWidth,
                            height: processedHeight
                        });
                    } catch (e) {
                        console.error('이미지 URL 생성 오류:', e);
                        resolve({
                            original: imageUrl,
                            processed: imageUrl,
                            width: img.width,
                            height: img.height
                        });
                    }
                    
                } catch (error) {
                    console.error('이미지 처리 오류:', error);
                    // 오류 시 원본 반환
                    resolve({
                        original: imageUrl,
                        processed: imageUrl,
                        width: img.width,
                        height: img.height
                    });
                }
            };
            
            img.onerror = function(error) {
                console.error('이미지 로딩 오류:', error);
                reject(new Error('이미지 로딩에 실패했습니다.'));
            };
            
            img.src = imageUrl;
            
        } catch (error) {
            console.error('이미지 전처리 초기화 오류:', error);
            reject(error);
        }
    });
}

// Otsu 임계값 계산 - 자동 이진화 임계값 결정
function calculateOtsuThreshold(histogram, totalPixels) {
    let sum = 0;
    for (let i = 0; i < 256; i++) {
        sum += i * histogram[i];
    }
    
    let sumB = 0;
    let wB = 0;
    let wF = 0;
    let maxVariance = 0;
    let threshold = 0;
    
    for (let i = 0; i < 256; i++) {
        wB += histogram[i];
        
        if (wB === 0) continue;
        
        wF = totalPixels - wB;
        if (wF === 0) break;
        
        sumB += i * histogram[i];
        
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        
        const variance = wB * wF * Math.pow(mB - mF, 2);
        
        if (variance > maxVariance) {
            maxVariance = variance;
            threshold = i;
        }
    }
    
    return threshold;
}

// 가우시안 블러 적용 - 노이즈 감소
function applyGaussianBlur(data, width, height, radius) {
    // 간소화된 가우시안 블러 구현 (실제로는 더 복잡함)
    // 임시 배열 생성
    const tempData = new Uint8ClampedArray(data.length);
    for (let i = 0; i < data.length; i++) {
        tempData[i] = data[i];
    }
    
    const kernel = generateGaussianKernel(radius);
    const kernelSize = radius * 2 + 1;
    
    // 가로 방향 블러
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0;
            let weightSum = 0;
            
            for (let kx = -radius; kx <= radius; kx++) {
                const posX = Math.min(Math.max(x + kx, 0), width - 1);
                const kernelValue = kernel[kx + radius];
                const idx = (y * width + posX) * 4;
                
                r += tempData[idx] * kernelValue;
                g += tempData[idx + 1] * kernelValue;
                b += tempData[idx + 2] * kernelValue;
                weightSum += kernelValue;
            }
            
            const destIdx = (y * width + x) * 4;
            data[destIdx] = r / weightSum;
            data[destIdx + 1] = g / weightSum;
            data[destIdx + 2] = b / weightSum;
        }
    }
    
    // 임시 배열에 중간 결과 복사
    for (let i = 0; i < data.length; i++) {
        tempData[i] = data[i];
    }
    
    // 세로 방향 블러
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0;
            let weightSum = 0;
            
            for (let ky = -radius; ky <= radius; ky++) {
                const posY = Math.min(Math.max(y + ky, 0), height - 1);
                const kernelValue = kernel[ky + radius];
                const idx = (posY * width + x) * 4;
                
                r += tempData[idx] * kernelValue;
                g += tempData[idx + 1] * kernelValue;
                b += tempData[idx + 2] * kernelValue;
                weightSum += kernelValue;
            }
            
            const destIdx = (y * width + x) * 4;
            data[destIdx] = r / weightSum;
            data[destIdx + 1] = g / weightSum;
            data[destIdx + 2] = b / weightSum;
        }
    }
}

// 가우시안 커널 생성
function generateGaussianKernel(radius) {
    const size = radius * 2 + 1;
    const kernel = new Array(size);
    
    const sigma = radius / 3;
    let sum = 0;
    
    for (let i = 0; i < size; i++) {
        const x = i - radius;
        kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
        sum += kernel[i];
    }
    
    // 정규화
    for (let i = 0; i < size; i++) {
        kernel[i] /= sum;
    }
    
    return kernel;
}

// 적응형 이진화 - 로컬 영역 기반 임계값 적용
function applyAdaptiveThresholding(data, width, height, globalThreshold) {
    // 그레이스케일 변환
    for (let i = 0; i < data.length; i += 4) {
        const gray = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
        
        // 전역 임계값 기반 이진화 (간소화된 구현)
        const threshold = globalThreshold;
        
        if (gray > threshold + 10) {
            // 배경은 흰색
            data[i] = data[i + 1] = data[i + 2] = 255;
        } else {
            // 텍스트는 검은색
            data[i] = data[i + 1] = data[i + 2] = 0;
        }
    }
}

// Sauvola 지역 적응형 이진화 알고리즘 (동아시아 문자에 효과적)
function applySauvolaThresholding(data, width, height, windowSize, k) {
    // 그레이스케일 변환 및 임시 배열 생성
    const grayData = new Uint8Array(width * height);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            grayData[y * width + x] = Math.round((data[idx] + data[idx + 1] + data[idx + 2]) / 3);
        }
    }
    
    // 각 픽셀에 대해 주변 윈도우 평균 및 표준편차 계산
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            // 윈도우 영역 설정
            const startX = Math.max(0, x - windowSize);
            const endX = Math.min(width - 1, x + windowSize);
            const startY = Math.max(0, y - windowSize);
            const endY = Math.min(height - 1, y + windowSize);
            
            // 평균 및 분산 계산
            let sum = 0;
            let sqSum = 0;
            let count = 0;
            
            for (let wy = startY; wy <= endY; wy++) {
                for (let wx = startX; wx <= endX; wx++) {
                    const value = grayData[wy * width + wx];
                    sum += value;
                    sqSum += value * value;
                    count++;
                }
            }
            
            const mean = sum / count;
            const variance = sqSum / count - mean * mean;
            const stdDev = Math.sqrt(variance);
            
            // Sauvola 임계값 계산
            const threshold = mean * (1 + k * ((stdDev / 128) - 1));
            
            // 이진화 적용
            const idx = (y * width + x) * 4;
            const value = grayData[y * width + x];
            
            if (value > threshold) {
                data[idx] = data[idx + 1] = data[idx + 2] = 255; // 배경
            } else {
                data[idx] = data[idx + 1] = data[idx + 2] = 0; // 텍스트
            }
        }
    }
}

// 형태학적 연산 (팽창/침식) - 문자 형태 개선
function applyMorphologicalOperation(data, width, height, operation, radius) {
    // 이미지를 이진 배열로 변환
    const binaryImage = new Uint8Array(width * height);
    for (let i = 0; i < width * height; i++) {
        binaryImage[i] = data[i * 4] > 128 ? 1 : 0;
    }
    
    // 결과 저장용 배열
    const result = new Uint8Array(width * height);
    
    // 작업 수행
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let found = (operation === 'dilate') ? 0 : 1;
            
            // 주변 픽셀 검사
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const value = binaryImage[ny * width + nx];
                        
                        if (operation === 'dilate' && value === 1) {
                            found = 1;
                            break;
                        } else if (operation === 'erode' && value === 0) {
                            found = 0;
                            break;
                        }
                    }
                }
                if ((operation === 'dilate' && found === 1) || 
                    (operation === 'erode' && found === 0)) {
                    break;
                }
            }
            
            result[y * width + x] = found;
        }
    }
    
    // 결과를 원본 데이터에 적용
    for (let i = 0; i < width * height; i++) {
        const value = result[i] === 1 ? 255 : 0;
        const idx = i * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
    }
}

// 대비 향상 - 텍스트와 배경 구분 강화
function applyContrastEnhancement(data, width, height, factor) {
    for (let i = 0; i < data.length; i += 4) {
        // RGB 각 채널에 대해 대비 향상
        for (let c = 0; c < 3; c++) {
            // 픽셀 값을 -128~127 범위로 조정
            let value = data[i + c] - 128;
            // 대비 인자 적용
            value = value * factor;
            // 다시 0-255 범위로 조정
            value = value + 128;
            // 범위 제한
            data[i + c] = Math.min(255, Math.max(0, value));
        }
    }
}

// 언샤프 마스킹 - 텍스트 선명도 향상
function applyUnsharpMasking(data, width, height, amount) {
    // 블러된 이미지 생성 (간소화 구현)
    const tempData = new Uint8ClampedArray(data.length);
    for (let i = 0; i < data.length; i++) {
        tempData[i] = data[i];
    }
    
    // 3x3 평균 블러 적용
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) {
                let sum = 0;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                        sum += data[idx];
                    }
                }
                
                const avgValue = sum / 9;
                tempData[(y * width + x) * 4 + c] = avgValue;
            }
        }
    }
    
    // 언샤프 마스킹 적용 (원본 - 블러 = 디테일)
    for (let i = 0; i < data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
            const detail = data[i + c] - tempData[i + c];
            data[i + c] = Math.min(255, Math.max(0, data[i + c] + detail * amount));
        }
    }
}

// 고급 OCR 처리 함수 - 여러 인식 엔진 결합
async function enhancedOCRProcess(imageData, langCode) {
    try {
        // 인식 품질 향상을 위한 여러 단계 적용
        
        // 1. 전처리된 이미지 정보 가져오기
        const { processed, original, width, height } = imageData;
        
        // 2. 메인 Tesseract 작업 생성
        const mainWorker = await createOptimizedWorker(langCode);
        
        // 3. OCR 메인 처리 - 최적화된 설정
        let mainResult = null;
        
        try {
            // 메인 인식 시작
            showStatus('텍스트 인식 중... (1/2)', 'info');
            
            // 프로 수준의 OCR 설정
            await mainWorker.setParameters({
                tessjs_create_hocr: '1',           // HOCR 출력 활성화
                tessjs_create_tsv: '1',            // 좌표 정보 획득
                tessedit_pageseg_mode: 'PSM_AUTO', // 자동 페이지 세그먼트 모드
                tessedit_ocr_engine_mode: 'OEM_LSTM_ONLY', // 신경망 전용 모드
                preserve_interword_spaces: '1',    // 단어 간 간격 유지
                textord_heavy_nr: '1',             // 강한 노이즈 제거
                textord_min_linesize: '2.5',       // 최소 라인 크기 설정
                language_model_penalty_non_dict_word: '0.8', // 사전 외 단어 페널티 감소
                language_model_penalty_non_freq_dict_word: '0.9' // 빈도수 낮은 단어 페널티 감소
            });
            
            // 메인 OCR 실행
            mainResult = await mainWorker.recognize(processed);
            
            // 워커 종료
            mainWorker.terminate();
            
        } catch (error) {
            console.error('메인 OCR 처리 오류:', error);
            if (mainWorker) {
                try {
                    await mainWorker.terminate();
                } catch (e) {
                    console.warn('메인 워커 종료 실패:', e);
                }
            }
            // 오류 시 더 간단한 설정으로 재시도
            return fallbackOCRProcess(original, langCode);
        }
        
        // 4. 보조 OCR 실행 - 다른 세그먼트 모드로 시도
        let secondaryResult = null;
        
        try {
            // 보조 인식용 워커 생성
            showStatus('텍스트 인식 중... (2/2)', 'info');
            const secondaryWorker = await createOptimizedWorker(langCode);
            
            // 싱글 라인 모드 설정 (명함의 경우 각 줄이 중요한 정보를 담고 있음)
            await secondaryWorker.setParameters({
                tessedit_pageseg_mode: 'PSM_SINGLE_LINE',  // 한 줄씩 인식
                tessedit_ocr_engine_mode: 'OEM_LSTM_ONLY', // 신경망 모드
                preserve_interword_spaces: '1'             // 단어 간격 유지
            });
            
            // 보조 OCR 실행
            secondaryResult = await secondaryWorker.recognize(processed);
            
            // 워커 종료
            secondaryWorker.terminate();
            
        } catch (error) {
            console.error('보조 OCR 처리 오류:', error);
            // 보조 OCR 실패해도 계속 진행
        }
        
        // 5. 결과 병합 및 후처리
        const mergedText = mergeOCRResults(mainResult, secondaryResult);
        
        // 6. 결과 반환
        return {
            text: mergedText,
            confidence: mainResult?.data?.confidence || 0,
            words: mainResult?.data?.words || [],
            hocr: mainResult?.data?.hocr || null,
        };
        
    } catch (error) {
        console.error('고급 OCR 전체 처리 오류:', error);
        // 모든 오류 상황에서 대비책 함수 호출
        return fallbackOCRProcess(imageData.original, langCode);
    }
}

// 최적화된 Tesseract 워커 생성
async function createOptimizedWorker(langCode) {
    const worker = Tesseract.createWorker({
        // 로거 및 진행률 표시
        logger: progress => {
            if (progress.status === 'recognizing text') {
                const percentage = Math.round(progress.progress * 100);
                progressBarFill.style.width = `${percentage}%`;
            }
        },
        // Tesseract 작업자 메모리 제한
        workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/worker.min.js',
        // 언어 데이터 경로 설정
        langPath: 'https://tessdata.projectnaptha.com/4.0.0',
        // 코어 스크립트 경로
        corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@2.2.0/tesseract-core.wasm.js'
    });
    
    // 초기화
    await worker.load();
    await worker.loadLanguage(langCode);
    await worker.initialize(langCode);
    
    return worker;
}

// 대체 OCR 처리 (간소화된 접근)
async function fallbackOCRProcess(imageUrl, langCode) {
    try {
        const worker = Tesseract.createWorker({
            logger: progress => {
                if (progress.status === 'recognizing text') {
                    const percentage = Math.round(progress.progress * 100);
                    progressBarFill.style.width = `${percentage}%`;
                }
            }
        });
        
        await worker.load();
        await worker.loadLanguage(langCode);
        await worker.initialize(langCode);
        
        // 기본 설정만 사용
        await worker.setParameters({
            preserve_interword_spaces: '1'
        });
        
        // 이미지 인식
        const result = await worker.recognize(imageUrl);
        
        // 워커 종료
        await worker.terminate();
        
        return {
            text: result.data.text,
            confidence: result.data.confidence,
            words: [],
            hocr: null
        };
        
    } catch (error) {
        console.error('대체 OCR 처리 오류:', error);
        return {
            text: '',
            confidence: 0,
            words: [],
            hocr: null
        };
    }
}

// OCR 결과 병합 함수
function mergeOCRResults(mainResult, secondaryResult) {
    if (!mainResult) return '';
    
    let mainText = mainResult.data.text;
    
    // 보조 결과가 있으면 병합
    if (secondaryResult && secondaryResult.data) {
        const secondaryText = secondaryResult.data.text;
        const mainLines = mainText.split('\n');
        const secondaryLines = secondaryText.split('\n');
        
        // 각 라인별로 더 나은 결과 선택
        const mergedLines = [];
        
        for (let i = 0; i < Math.max(mainLines.length, secondaryLines.length); i++) {
            const mainLine = i < mainLines.length ? mainLines[i] : '';
            const secondaryLine = i < secondaryLines.length ? secondaryLines[i] : '';
            
            // 공백이 아닌 단어 수 계산
            const mainWordCount = mainLine.split(/\s+/).filter(w => w.length > 0).length;
            const secondaryWordCount = secondaryLine.split(/\s+/).filter(w => w.length > 0).length;
            
            // 특수문자 비율 계산
            const mainSpecialChar = countSpecialCharacters(mainLine);
            const secondarySpecialChar = countSpecialCharacters(secondaryLine);
            
            // 휴리스틱: 더 많은 단어와 더 적은 특수문자를 가진 결과 선택
            if (mainWordCount > secondaryWordCount && mainSpecialChar <= secondarySpecialChar) {
                mergedLines.push(mainLine);
            } else if (secondaryWordCount > 0 && 
                      (secondaryWordCount > mainWordCount || secondarySpecialChar < mainSpecialChar)) {
                mergedLines.push(secondaryLine);
            } else {
                mergedLines.push(mainLine || secondaryLine);
            }
        }
        
        mainText = mergedLines.join('\n');
    }
    
    // 후처리: 불필요한 공백 제거 및 텍스트 정리
    mainText = mainText.replace(/\s+/g, ' ').trim();  // 연속된 공백을 하나로
    mainText = mainText.replace(/(\n\s*)+/g, '\n');   // 연속된 줄바꿈 제거
    
    return mainText;
}

// 특수 문자 개수 세기
function countSpecialCharacters(text) {
    if (!text) return 0;
    return (text.match(/[^\w\s가-힣ぁ-んァ-ン一-龯]/g) || []).length;
}

// 전문적인 명함 정보 추출 로직
function advancedBusinessCardExtraction(text, hocrData, words, keywords, langCode) {
    try {
        console.log("고급 명함 정보 추출 시작", text);
        
        // 기본 정보 객체
        const info = {
            name: '',
            position: '',
            company: '',
            department: '',
            phone: '',
            email: '',
            address: '',
            fax: '',
            website: '',
            mobile: '',
            tel: ''
        };
        
        // 정제된 텍스트 라인 분리
        const lines = text.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);
        
        console.log("처리할 라인:", lines);
        
        // 1. 정규 표현식을 통한 정확한 정보 추출
        
        // 이메일 추출 - 가장 신뢰할 수 있는 패턴
        const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
        const emailMatches = text.match(emailRegex);
        if (emailMatches && emailMatches.length > 0) {
            info.email = emailMatches[0];
            console.log("이메일 발견:", info.email);
        }
        
        // 웹사이트 추출
        const websiteRegex = /(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+(?:\.[a-zA-Z]{2,})+/g;
        const websiteMatches = text.match(websiteRegex);
        if (websiteMatches && websiteMatches.length > 0) {
            // 이메일 주소와 겹치지 않는 첫 번째 웹사이트 선택
            for (const website of websiteMatches) {
                if (!website.includes('@')) {
                    info.website = website;
                    console.log("웹사이트 발견:", info.website);
                    break;
                }
            }
        }
        
        // 전화번호 추출 (여러 종류의 전화번호 구분)
        const phonePatterns = [
            // 모바일 패턴 (대부분의 국가 포맷)
            { 
                regex: /(?:M|Mobile|모바일|휴대폰|핸드폰|手机|携帯)[.:)]?\s*(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{4}/gi,
                type: 'mobile'
            },
            // 일반 전화 패턴
            { 
                regex: /(?:Tel|TEL|전화|T|P|Ph|电话)[.:)]?\s*(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{4}/gi,
                type: 'tel'
            },
            // 팩스 패턴
            { 
                regex: /(?:Fax|FAX|팩스|F)[.:)]?\s*(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{4}/gi,
                type: 'fax'
            },
            // 일반 숫자 패턴 (위에서 매치되지 않은 것)
            { 
                regex: /(?:\+?\d{1,4}[\s-]?)?(?:\(?\d{2,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{4}/g,
                type: 'phone'
            }
        ];
        
        // 매칭된 전화번호 저장 집합
        const matchedNumbers = new Set();
        
        // 각 패턴 유형에 따라 검색
        for (const pattern of phonePatterns) {
            const matches = text.match(pattern.regex);
            if (matches && matches.length > 0) {
                for (const match of matches) {
                    // 이미 추출한 번호는 건너뛰기
                    if (matchedNumbers.has(match)) continue;
                    
                    // 숫자만 추출
                    const digitsOnly = match.replace(/\D/g, '');
                    
                    // 전화번호가 너무 짧거나 길면 건너뛰기
                    if (digitsOnly.length < 7 || digitsOnly.length > 15) continue;
                    
                    // 숫자 부분 추출하여 형식화
                    let formattedNumber = match;
                    
                    // 이미 추출한 다른 타입과 겹치는지 확인
                    const isUnique = ![info.phone, info.tel, info.mobile, info.fax]
                        .filter(Boolean)
                        .some(num => num.replace(/\D/g, '') === digitsOnly);
                    
                    if (isUnique) {
                        // 타입에 따라 저장
                        if (pattern.type === 'mobile' && !info.mobile) {
                            info.mobile = formattedNumber;
                            console.log("모바일 번호 발견:", info.mobile);
                        } else if (pattern.type === 'tel' && !info.tel) {
                            info.tel = formattedNumber;
                            console.log("전화번호 발견:", info.tel);
                        } else if (pattern.type === 'fax' && !info.fax) {
                            info.fax = formattedNumber;
                            console.log("팩스 번호 발견:", info.fax);
                        } else if (pattern.type === 'phone' && !info.phone) {
                            info.phone = formattedNumber;
                            console.log("기타 전화번호 발견:", info.phone);
                        }
                        
                        // 매칭된 번호 저장
                        matchedNumbers.add(match);
                    }
                }
            }
        }
        
        // 전화번호가 없는데 mobile이 있으면 phone에 할당
        if (!info.phone && info.mobile) {
            info.phone = info.mobile;
        }
        
        // 2. 언어별 패턴 및 키워드 분석으로 회사, 이름, 직책 추출
        
        // 라인 데이터를 복사 (사용한 라인은 제거할 예정)
        let remainingLines = [...lines];
        
        // 회사명 추출 (키워드 기반)
        for (let i = 0; i < remainingLines.length; i++) {
            const line = remainingLines[i];
            if (keywords.company.some(keyword => line.includes(keyword))) {
                info.company = line;
                console.log("회사명 발견:", info.company);
                remainingLines.splice(i, 1);
                break;
            }
        }
        
        // 회사명이 없으면, 위치 기반 추론
        if (!info.company && remainingLines.length > 1) {
            // 명함에서 회사명은 종종 첫 번째나 두 번째 줄에 있음
            const possibleCompanyLines = remainingLines.slice(0, Math.min(3, remainingLines.length));
            
            // 가장 긴 첫 번째, 두 번째 줄을 회사명으로 간주
            const longestLine = possibleCompanyLines.reduce((a, b) => 
                (a.length >= b.length) ? a : b, '');
                
            if (longestLine && longestLine.length > 3) {
                info.company = longestLine;
                console.log("추정 회사명:", info.company);
                const index = remainingLines.indexOf(longestLine);
                if (index !== -1) {
                    remainingLines.splice(index, 1);
                }
            }
        }
        
        // 이름 추출 (언어별 패턴 기반)
        let nameFound = false;
        
        // 언어별 이름 패턴 적용
        switch(langCode) {
            case 'kor':
                // 한국어 이름 패턴 (2-4자 한글)
                for (let i = 0; i < remainingLines.length; i++) {
                    const line = remainingLines[i].trim();
                    // 직책이 붙은 이름 패턴 (예: "홍길동 대표이사" 또는 "대표이사 홍길동")
                    const nameWithTitleMatch = line.match(/^([가-힣]{2,4})\s+.+$/) || line.match(/^.+\s+([가-힣]{2,4})$/);
                    if (nameWithTitleMatch) {
                        info.name = nameWithTitleMatch[1];
                        // 직책 부분 추출
                        const titlePart = line.replace(info.name, '').trim();
                        if (titlePart && !info.position) {
                            info.position = titlePart;
                        }
                        nameFound = true;
                        console.log("이름과 직책 발견:", info.name, info.position);
                        remainingLines.splice(i, 1);
                        break;
                    }
                    
                    // 단독 이름 패턴
                    const soloNameMatch = line.match(/^[가-힣]{2,4}$/);
                    if (soloNameMatch) {
                        info.name = line;
                        nameFound = true;
                        console.log("이름 발견:", info.name);
                        remainingLines.splice(i, 1);
                        break;
                    }
                }
                break;
                
            case 'eng':
                // 영어 이름 패턴 (First Last 또는 Last, First)
                for (let i = 0; i < remainingLines.length; i++) {
                    const line = remainingLines[i].trim();
                    // 영어 이름 패턴 (1-2단어, 각 단어는 대문자로 시작)
                    const engNamePattern = /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)$/;
                    if (engNamePattern.test(line)) {
                        info.name = line;
                        nameFound = true;
                        console.log("영어 이름 발견:", info.name);
                        remainingLines.splice(i, 1);
                        break;
                    }
                }
                break;
                
            case 'jpn':
                // 일본어 이름 패턴
                for (let i = 0; i < remainingLines.length; i++) {
                    const line = remainingLines[i].trim();
                    // 한자나 히라가나/가타카나로 구성된 2-4자 이름
                    if (/^[一-龯ぁ-んァ-ン]{2,4}$/.test(line)) {
                        info.name = line;
                        nameFound = true;
                        console.log("일본어 이름 발견:", info.name);
                        remainingLines.splice(i, 1);
                        break;
                    }
                }
                break;
                
            case 'chi_sim':
                // 중국어 이름 패턴
                for (let i = 0; i < remainingLines.length; i++) {
                    const line = remainingLines[i].trim();
                    // 한자로 구성된 2-4자 이름
                    if (/^[\u4e00-\u9fff]{2,4}$/.test(line)) {
                        info.name = line;
                        nameFound = true;
                        console.log("중국어 이름 발견:", info.name);
                        remainingLines.splice(i, 1);
                        break;
                    }
                }
                break;
                
            default:
                // 다국어 지원 - 모든 패턴 시도
                for (let i = 0; i < remainingLines.length; i++) {
                    const line = remainingLines[i].trim();
                    
                    // 가장 짧은 줄이 이름일 가능성이 높음 (2-10자 사이)
                    if (line.length >= 2 && line.length <= 10 && 
                        !/^\d+$/.test(line) && // 숫자만으로 구성되지 않음
                        !line.includes('@') && // 이메일 아님
                        !line.includes('http')) { // URL 아님
                        info.name = line;
                        nameFound = true;
                        console.log("다국어 이름 추정:", info.name);
                        remainingLines.splice(i, 1);
                        break;
                    }
                }
                break;
        }
        
        // 이름을 찾지 못한 경우, 가장 짧은 줄을 이름으로 추정
        if (!nameFound && remainingLines.length > 0) {
            // 짧은 줄 중에서 선택 (이메일, URL 제외)
            const shortLines = remainingLines
                .filter(line => line.length <= 15 && !line.includes('@') && !line.includes('http'));
                
            if (shortLines.length > 0) {
                // 가장 짧은 줄을 이름으로 간주
                const shortestLine = shortLines.reduce((a, b) => a.length <= b.length ? a : b);
                info.name = shortestLine;
                console.log("추정 이름:", info.name);
                const index = remainingLines.indexOf(shortestLine);
                if (index !== -1) {
                    remainingLines.splice(index, 1);
                }
            }
        }
        
        // 직책 추출 (키워드 기반)
        if (!info.position) {
            for (let i = 0; i < remainingLines.length; i++) {
                const line = remainingLines[i];
                if (keywords.position.some(keyword => line.includes(keyword))) {
                    info.position = line;
                    console.log("직책 발견:", info.position);
                    remainingLines.splice(i, 1);
                    break;
                }
            }
        }
        
        // 부서 추출 (키워드 기반)
        for (let i = 0; i < remainingLines.length; i++) {
            const line = remainingLines[i];
            if (keywords.department.some(keyword => line.includes(keyword))) {
                info.department = line;
                console.log("부서 발견:", info.department);
                remainingLines.splice(i, 1);
                break;
            }
        }
        
        // 주소 추출 (가장 긴 줄 또는 특수 패턴)
        const addressPatterns = {
            kor: /(?:서울|부산|대구|인천|광주|대전|울산|세종|경기|강원|충북|충남|전북|전남|경북|경남|제주)[\s,].*(?:로|길|동|구|시|군|읍|면|번지|층|호)/,
            eng: /\d+\s+[A-Za-z\s,]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Way|Court|Ct|Plaza|Square|Sq|Highway|Hwy|Freeway|Fwy)/i,
            jpn: /(?:東京都|大阪府|京都府|北海道|[一-龯]{1,3}県)[\s,].*(市|区|町|村|丁目|番地)/,
            chi_sim: /(?:北京市|上海市|天津市|重庆市|[一-龯]{1,3}省)[\s,].*(市|区|县|路|街|号)/
        };
        
        // 언어별 주소 패턴 확인
        const currentLangPattern = addressPatterns[langCode.split('+')[0]] || 
                                 addressPatterns[langCode === 'multi' ? 'eng' : langCode];
        
        if (currentLangPattern) {
            for (let i = 0; i < remainingLines.length; i++) {
                const line = remainingLines[i];
                if (currentLangPattern.test(line)) {
                    info.address = line;
                    console.log("주소 패턴 발견:", info.address);
                    remainingLines.splice(i, 1);
                    break;
                }
            }
        }
        
        // 주소를 못 찾았으면 남은 줄 중 가장 긴 줄을 주소로 간주
        if (!info.address && remainingLines.length > 0) {
            // 이메일, URL 제외하고 가장 긴 줄 찾기
            const longLines = remainingLines
                .filter(line => !line.includes('@') && !line.includes('http'));
                
            if (longLines.length > 0) {
                // 가장 긴 줄을 주소로 간주
                const longestLine = longLines.reduce((a, b) => a.length >= b.length ? a : b);
                if (longestLine.length > 10) { // 최소 길이 제한
                    info.address = longestLine;
                    console.log("추정 주소:", info.address);
                    const index = remainingLines.indexOf(longestLine);
                    if (index !== -1) {
                        remainingLines.splice(index, 1);
                    }
                }
            }
        }
        
        // 3. 결과 후처리 및 정제
        
        // 불필요한 접두사/접미사 제거
        if (info.name) {
            // 이름에서 직함 제거
            const titlePrefixes = ['Mr.', 'Ms.', 'Dr.', 'Prof.', 'MD', 'PhD', '대리', '과장', '차장', '부장', '이사', '상무', '전무', '사장', '대표'];
            for (const prefix of titlePrefixes) {
                if (info.name.includes(prefix)) {
                    info.name = info.name.replace(prefix, '').trim();
                }
            }
        }
        
        // 전화번호 포맷 통일
        if (info.phone) {
            info.phone = formatPhoneNumber(info.phone);
        }
        
        // 최종 결과 반환
        return info;
        
    } catch (error) {
        console.error('고급 명함 정보 추출 오류:', error);
        // 오류 발생 시 기본 추출 함수 사용
        return extractBasicInfo(text, keywords);
    }
}

// 전화번호 포맷팅 함수
function formatPhoneNumber(phoneNumber) {
    // 숫자만 추출
    const digits = phoneNumber.replace(/\D/g, '');
    
    // 국가 코드 확인
    if (digits.startsWith('82')) {
        // 한국 번호
        const withoutCountryCode = digits.substring(2);
        if (withoutCountryCode.length === 10) {
            // 02-XXXX-XXXX 또는 010-XXX-XXXX 등의 형식
            return withoutCountryCode.replace(/(\d{2})(\d{4})(\d{4})/, '$1-$2-$3');
        } else if (withoutCountryCode.length === 9) {
            // 02-XXX-XXXX 형식
            return withoutCountryCode.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
        }
    }
    
    // 기본 포맷팅
    if (digits.length === 11) {
        return digits.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
    } else if (digits.length === 10) {
        return digits.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
    } else if (digits.length === 8) {
        return digits.replace(/(\d{4})(\d{4})/, '$1-$2');
    }
    
    // 기본값 반환
    return phoneNumber;
}

// 분석 버튼에 연결할 전문적인 분석 함수
function setupProfessionalAnalysisButton() {
    analyzeBtn.addEventListener('click', async () => {
        // 진행 상태 표시
        showStatus('명함 분석 준비 중...', 'info');
        progressBar.style.display = 'block';
        progressBarFill.style.width = '0%';
        analyzeBtn.disabled = true;
        
        try {
            // 이미지 검증
            if (!capturedImage.src || !capturedImage.complete || capturedImage.naturalWidth === 0) {
                throw new Error('유효한 이미지가 없습니다. 다시 촬영해주세요.');
            }
            
            // 언어 설정 가져오기
            const langConfig = languageMap[selectedLanguage];
            if (!langConfig) {
                throw new Error('지원되지 않는 언어입니다.');
            }
            
            // 1. 고급 이미지 전처리
            showStatus('이미지 최적화 중...', 'info');
            const enhancedImage = await advancedPreprocessImage(capturedImage.src);
            
            // 2. 고급 OCR 처리
            showStatus('텍스트 인식 중...', 'info');
            const ocrResult = await enhancedOCRProcess(enhancedImage, langConfig.lang);
            
            // 인식 결과 검증
            if (!ocrResult.text || ocrResult.text.trim().length === 0) {
                throw new Error('텍스트를 인식할 수 없습니다. 더 선명한 이미지로 다시 시도해주세요.');
            }
            
            console.log('인식된 텍스트:', ocrResult.text);
            console.log('인식 신뢰도:', ocrResult.confidence);
            
            // 3. 고급 명함 정보 추출
            showStatus('정보 분석 중...', 'info');
            const extractedInfo = advancedBusinessCardExtraction(
                ocrResult.text, 
                ocrResult.hocr, 
                ocrResult.words,
                langConfig.keywords,
                langConfig.lang
            );
            
            // 4. 추출된 정보를 폼에 채우기
            document.getElementById('name').value = extractedInfo.name || '';
            document.getElementById('position').value = extractedInfo.position || '';
            document.getElementById('company').value = extractedInfo.company || '';
            document.getElementById('department').value = extractedInfo.department || '';
            document.getElementById('phone').value = extractedInfo.phone || extractedInfo.mobile || extractedInfo.tel || '';
            document.getElementById('email').value = extractedInfo.email || '';
            document.getElementById('address').value = extractedInfo.address || '';
            
            // 폼에 웹사이트나 팩스 정보가 있으면 메모 필드에 추가
            const additionalInfo = [];
            if (extractedInfo.website) additionalInfo.push(`웹사이트: ${extractedInfo.website}`);
            if (extractedInfo.fax) additionalInfo.push(`팩스: ${extractedInfo.fax}`);
            
            if (additionalInfo.length > 0) {
                document.getElementById('notes').value = additionalInfo.join('\n');
            }
            
            // 폼 표시
            cardForm.style.display = 'block';
            
            // 진행 상태 업데이트
            showStatus(`명함 분석 완료! (신뢰도: ${Math.round(ocrResult.confidence)}%)`, 'success');
            progressBarFill.style.width = '100%';
            setTimeout(() => {
                progressBar.style.display = 'none';
                analyzeBtn.disabled = false;
            }, 1500);
            
        } catch (error) {
            console.error('명함 분석 오류:', error);
            
            // 오류 메시지 표시
            showStatus(`오류: ${error.message || '명함 분석 중 문제가 발생했습니다.'}`, 'error');
            
            setTimeout(() => {
                progressBar.style.display = 'none';
                analyzeBtn.disabled = false;
            }, 3000);
        }
    });
}
